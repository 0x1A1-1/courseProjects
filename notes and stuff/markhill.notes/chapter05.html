<!--#include virtual="style1.html" -->

Lecture Notes for
Chapter 5 -- Arithmetic and Logical Operations <!-- EDIT CHAPTER INFO -->

<!--#include virtual="style2.html" -->

<!--#echo var="LAST_MODIFIED" -->

<!--#include virtual="style3.html" -->


Operations we'll get to know (and love):

    addition
    subtraction
    multiplication
    division
    logical ops
    shifting

--------
ADDITION
--------


A LITTLE BIT ON ADDING
----------------------
  an overview.


       a      0011
      +b     +0001
      --     -----
     sum      0100


  its really just like we do for decimal!
    0 + 0 = 0
    1 + 0 = 1
    1 + 1 = 2  which is 10 in binary, sum is 1 and carry the 1.
    1 + 1 + 1 = 3  sum is 0, and carry a 1.

	carry in  a  b   sum  carry out
	   0      0  0    0    0
	   0      0  1    1    0
	   0      1  0    1    0
	   0      1  1    0    1
	   1      0  0    1    0
	   1      0  1    0    1
	   1      1  0    0    1
	   1      1  1    1    1


Ignore overflow for now.

Addition w/ unsigned
--------------------

  just like the simple addition given.

  examples:

      100001           00001010 (10)
     +011101          +00001110 (14)
     -------          ---------
      111110           00011000 (24)

      (ignoring overflow)



Addition w/ 2SC
---------------

For non-negatives (0 and positives) ==> just like unsigned add


Assume 5-bit and observe:


    00011 (3)         101000  (-24)        111111 (-1)
  + 11100 (-4)      + 010000  (16)       + 001000 (8)
  ------------      --------             --------
    11111 (-1)        111000  (-8)        1 000111 (7)

    Ignore carry-outs (and overflow)


Add w/ sign magnitude:
---------------------

  rules:
    - add magnitudes only (do not carry into the sign bit)
    - throw away any carry out of the msb of the magnitude
    - add only integers of like sign ( + to +    or    - to -)
    - sign of result is same as sign of the addends

  examples:

    0  0101 (5)        1  1010 (-10)
  + 0  0011 (3)      + 1  0011 (-3)
  ---------          ---------
    0  1000 (8)        1  1101 (-13)


    0  01011 (11)
  + 1  01110 (-14)
  ----------------
  don't add! must do subtraction!

Add w/ one's complement:
-----------------------

   by example


    00111 (7)         111110 (-1)            11110 (-1)
  + 00101 (5)       + 000010 (2)           + 11100 (-3)
  -----------       ------------           ------------
    01100 (12)      1 000000 (0) wrong!    1 11010 (-5) wrong
			+  1                  +  1
		      ----------             ----------
		      000001 (1)             11011 (-4)


   so it seems that if there is a carry out of the msb, then
   the result will be off by 1, so add 1 again to get the correct
   result.




-----------
SUBTRACTION
-----------

  general rules:
    1 - 1 = 0
    0 - 0 = 0
    1 - 0 = 1
   10 - 1 = 1
    0 - 1 = borrow!

But often we can do a - b as a + (-b)
	i.e., replace substraction with additive inverse & addition


Subtraction w/ 2SC
------------------

Don't bother use addition:

       a - b  becomes   a + (-b)

  - so, get the additive inverse of b, and do addition.

    examples

   10110 (-10)
 - 00011 (3)    -->       00011
 ------------               |
			   \|/
			  11100
			+     1
			-------
			  11101 (-3)

Apply to otherwise unused LSB carry in:

     10110 (-10)
   + 11101 (-3)
   ------------
  1  10011  (-13)
  (throw away carry out)

Actually use 1SC and apply 1 to otherwise unused LSB carry in:

	 1 <------+
     10110 (-10)  |
   + 11100 <------+--- (-3)
   ------------
  1  10011  (-13)
  (throw away carry out)


Why use 2SC?  Can do a+b and a-b, with a positive or negative
and b positive or negative with adders and inverters.



Subtraction w/ unsigned
-----------------------

For n-bits use above 2SC method and overflow if negative

      11100 (+28)
    - 10110 (+22)
    -------------

==>

	  1
      11100 (+28)
    + 01001 (-22 w/ carry above)
    -------------
      00110 (+6)



Subtraction w/ sign magnitude
-----------------------------


sign magnitude:

  - if the signs are the same, then  do subtraction
  - if signs are different, then change the problem to addition
  - compare magnitudes, then subtract smaller from larger
  - if the order is switched, then switch the sign too.

  - when the integers are of the opposite sign, then do
	a - b    becomes   a + (-b)
	a + b    becomes   a - (-b)


     examples

   0 00111 (7)             1 11000 (-24)
 - 0 11000 (24)          - 1 00010 (-2)
 --------------          --------------
                           1 10110 (-22)
do 0 11000 (24)
 - 0 00111 (7)
 --------------
   1 10001 (-17)
   (switch sign since the order of the subtraction was reversed)



one's complement:

     figure it out on your own








more on integer arithmetic
-------------------------


OVERFLOW DETECTION IN ADDITION

  unsigned -- when there is a carry out of the msb

	   1000 (8)
	  +1001 (9)
	  -----
	 1 0001 (1)

  sign magnitude -- when there is a carry out of the msb of the magnitude

	 1 1000 (-8)
       + 1 1001 (-9)
	  -----
	 1 0001 (-1)  (carry out of msb of magnitude)

  2's complement -- when the signs of the addends are the same, and the
		    sign of the result is different


	  0011 (3)
	+ 0110 (6)
	----------
	  1001 (-7)   (note that a correct answer would be 9, but
		       9 cannot be represented in 4 bit 2's complement)

  a detail -- you will never get overflow when adding 2 numbers of
	      opposite signs


OVERFLOW DETECTION IN SUBTRACTION

   unsigned -- if negative
   sign magnitude -- never happen when doing subtraction
   2's complement -- we never do subtraction, so use the addition rule
      on the addition operation done.




MULTIPLICATION of integers (non-negative)

	  multiplicand
	x   multiplier
	--------------
	       product

	       0011 (+3)
	     x 0110 (+6)
	       ----
	       0000
	      0011
	     0011
	    0000
	    -------
	    0010010 (+18)

     
     0 x 0 = 0
     0 x 1 = 0
     1 x 0 = 0
     1 x 1 = 1

     -- longhand, it looks just like decimal

     -- the result can require 2x as many bits as the larger multiplicand

     For 2SC:

     If negative multiplicand, just sign-extend it.

     If negative multiplier, take 2SC of both multiplicand and multiplier
     (-7 * -3 = 7 * 3;  7 * -3 = -7 * 3)

     Easier than book's method.
	2x as many bits (as the larger).  Then take the correct number
	of result bits from the least significant portion of the result.



	A simpler approach:  If multiplier negative, take 2SC of both

 
    2's complement example:
	
	  0011 (3)
	* 1011 (-5)
	-----------
	
	            1101 (-3)
	          * 0101 (+5)
	        -------------
	     11111111101
	     0000000000
	     111111101
	  +  00000000
	  -------------------
	     11111110001 (-18)



DIVISION of integers
--------------------
     unsigned only!

     do example of 15 / 3         1111 / 011


Logical operations
------------------
Operate on raw bits 
	1 == true
	0 == false


	in1 in2		and  or	 nand   nor xor xnor (equal)
	  0 0		 0   0    1	 1   0   1
	  0 1		 0   1    1	 0   1   0
	  1 0		 0   1    1	 0   1   0
	  1 1		 1   1	  0      0   0   1

    In Computer, done bitwise (in parallel for corresponding bits)


                     X =  0011
                     Y =  1010

       X  AND  Y is       0010
       X   OR  Y is       1011
       X  NOR  Y is       0100
       X  XOR  Y is       1001
                etc.


SAL LOGICAL INSTRUCTIONS


   operate bitwise on 32 .words

	not   x, y         x <-  NOT (y)
	and   x, y, z      x <-  (y) AND (z)
	or    x, y, z      x <-  (y) OR (z)
	nor   x, y, z      x <-  (y) NOR (z)
	nand  x, y, z      x <-  (y) NAND (z)
	xor   x, y, z      x <-  (y) XOR (z)
	xnor  x, y, z      x <-  (y) XNOR (z)



Example:

   a:	.word 0x00000003	# 0...0 0011
   b:	.word 0x0000000a	# 0...0 1010
   c:   .word
   d:   .word

   .text
   and c,a,b			# 0...0 0010
   or c,a,b			# 0...0 1011



Example:

   abcd:  .word	0x61626364
   mask: .word	0x000000ff
   tmp:	  .word 

   .text
   and tmp,abcd,mask
   beq tmp,'d',found_d
   ...

Add:
   mask2:  .word 0x0000ff00
   ...
   and tmp,abcd,mask
   beq tmp,'c',found_c WRONG!  Need shift



Shifts and Rotates
------------------

USE PICTURES FROM pp. 118-120

	   
  logical right - move bits to the right, same order
	       - throw away the bit that pops off the lsb
	       - introduce a 0 into the msb

	       00110101

	       00011010

  logical left - move bits to the left, same order
	       - throw away the bit that pops off the msb
	       - introduce a 0 into the lsb


	       00110101

	       01101010


  arithmetic right - move bits to the right, same order
	       - throw away the bit that pops off the lsb
	       - reproduce the original msb into the new msb 
	       - another way of thinking about it:  shift the
		 bits, and then do sign extension

	       00110101        1100

	       00011010        1110


  arithmetic left - move bits to the left, same order
	       - throw away the bit that pops off the msb
	       - introduce a 0 into the lsb
	       - SAME AS LOGICAL LEFT SHIFT!


  rotate left - move bits to the left, same order
	      - put the bit that pops off the msb into the lsb,
		so no bits are thrown away or lost.

	       00110101        1100

	       01101010        1001


  rotate right - move bits to the right, same order
	      - put the bit that pops off the lsb into the msb,
		so no bits are thrown away or lost.

	       00110101        1100
	       10011010        0110


SAL SHIFT AND ROTATE INSTRUCTIONS

	sll   x, y, value     x <- (y), logically left shifted by value bits
	srl   x, y, value     x <- (y), logically right shifted by value bits
	sra   x, y, value     x <- (y), arithmetically right shifted by
					value bits
	rol   x, y, value     x <- (y), rotated left by value bits
	ror   x, y, value     x <- (y), rotated right by value bits

the rules for doing the arithmetic operations vary depending
on what representation is implied.


Example:

   abcd:  .word	0x61626364
   mask2:  .word 0x0000ff00
   tmp:	  .word 

   .text
   and tmp,abcd,mask2
   srl tmp,tmp,8
   beq tmp,'c',found_c



Optional Examples

A common student question occurs as a result of learning of
the shift and logical operations:  what are they used for?

Here are some examples as a partial answer to the question.


  Example 1:
      A certain program has a bunch of boolean values that
      it will need to maintain.

      Place all these (bit-sized) variables into one (word-sized)
      integer variable:

      Bit number:     31     30 . . . .  2    1    0
      Contents       var31  var30       var2 var1 var0

      So, we've got up to 32 variables placed into one integer.
      Let this integer be called var.

      What would we want to do to these boolean variables?
      Answer:  individually set (make a 1) or clear (make a 0)
      a variable.


      SAL code to set var5:

              or  var, var, 0x00000020
      Whatever was in all bits other than bit 5 remain the same,
      and bit 5 (called var5 for this example, but not in code)
      gets the value 1.



      SAL code to clear var12 and var3:

              and  var, var, 0xffffeff7
      Whatever was in all bits other than bits 12 and 3 remain the same,
      and bits 12 and 3 get the value 0.

      The value 0xffffeff7 (or 0x00000010 in the previous example)
      is called a MASK.  It specifies the settings of bits.
      Here is the mapping of some of the bits to show how the
      mask was created.

      bit #      15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      contents    1  1  1  0  1  1  1  1  1  1  1  1  0  1  1  1



  Example 2:
      Suppose that we want to do operations on strings.
      (A string is a bunch of characters that happen to reside
      next to each other in memory.)

      What operations might be appropriate?
         Insert characters?  Concatenate strings?  Switch order
	 of characters?  Change lower case to upper case?

      What do strings look like?
         The ASCII characters are placed into memory one following
	 another.  Yet, to operate on parts of strings, we might
	 want to work on integer-sized chunks. . .
	 An operand the size of an integer is most often called
	 a WORD on a computer.


	 Part of a string in a 32-bit word:
	   
           -------------------------
	   | 'A' | 'B' | 'C' | 'D' |
           -------------------------

      Call this variable x.  Write a SAL code fragment that
      reverses the middle two characters, without changing
      the rest.


           and   temp1, x, 0x00ff0000   # extract out the 'B' byte
           and   temp2, x, 0x0000ff00   # extract out the 'C' byte
	   and   x, x, 0xff0000ff       # clear middle 2 bytes
	   srl   temp1, temp1, 8        # move the 'B' 1 byte to right
	   sll   temp2, temp2, 8        # move the 'C' 1 byte to left
	   or    x, x, temp1            # merge moved 'B' back in
	   or    x, x, temp2            # merge moved 'C' back in


Review
-------
    addition
    subtraction
    multiplication
    division
    logical ops
    shifting

<!--#include virtual="style4.html" -->
