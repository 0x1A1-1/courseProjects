<!--#include virtual="style1.html" -->

Lecture Notes for
Chapter 12 -- Interrupts and Exception Handling <!-- EDIT CHAPTER INFO -->

<!--#include virtual="style2.html" -->

<!--#echo var="LAST_MODIFIED" -->

<!--#include virtual="style3.html" -->


</PRE>
<P>
<b>Students should also print
<A HREF="http://www.cs.wisc.edu/~cs354-2/cs354/markhill.notes/chapter12kernel_gist.html">kernel gist</a>
and
<A HREF="http://www.cs.wisc.edu/~cs354-2/cs354/markhill.notes/chapter12kernel.html">kernel</a>.
</b>
<PRE>

For I/O
	Why have SW repeatedly ask a device, "Are you ready?" (polling).
	Instead have device tell SW, "I am ready!" (interrupt)


Device needs HW wire into CPU.

This wire must somehow influence SW.

DRAW PICTURE -- SPEND CONSIDERABLE TIME MOTIVATING

Interrupts
----------
Examples
    I/O device
	    change in status	<== we will concentrate on this
	    error condition
    processor problem
	    thermal overide shutdown
	    internal error detected
    clock
    ...

Properties
    they arrive asynchronously
    can't communmicate with running program (no args or return values)
    they are associated with various priorities

Want to handle soon (interrupt latency)
(Usually) want to resume program (may even be other user's I/O!)


Traps
-----
Related to interrupts

Examples
    syscall	<== we will concentrate on this
    illegal instruction
    arithmetic overflow
    lw from unaligned address
    ...

Properties
    they arrive synchronously -- i.e. pertain to specific instruction
    (get trap in same place if your re-run program)
    they are associated with various priorities

Must handle immediately
(Usually) want to resume program


Exception
---------

(People often incorrectly mix up the terms interrupt, trap and exception.)

Mechanism used to handle both interrupts and traps
	HW handles initial reaction
	then invokes SW called an Exception Handler

HW
 1. sets state giving cause of exception
 2. changes to kernel mode, saving the previous mode
    in a hardware stack (3 levels deep) -- for dangerous work ahead
 3. disables further interrupts -- to prevent infinite loop
 4. saves current PC -- to able to resume previously-running program
 5. jumps to hardwired address 0x8000 0080.


Exception Handler (.ktext beginning at 0x80000080)
	Set flag to detect incorrect entry
	(due to exception while in exception handler)
	Saves some registers
	Assertain exception type (MIPS: exception_code in Cause register)
	(e.g., I/O interrupt or syscall)
	Jump to specific exception handler

	Handle specific exceptions

	To resume program, jump to clean up routine
	Restore registers
	Reset flag (that detects incorrect entry)
	Atomically
		Restore previous mode
		Reenable interrupts
		Jump back to program (using EPC)


Syscall handler (1 of 2 specfic exceptions we examine)

	Change EPC to point to next instruction 
	(to prevent infinite syscall loop)

	Look at syscall number (MIPS: $2)
	(e.g., putc is 11 and getc 12) 
	Jump to specfic syscall handler


putc handler (one of many syscall handlers)
	Add char (from $4) to putqueue
	Turn on display interrupts
	Try to print a char	# note to me: DP_handler
	Jump back to main exception handler

getc handler
	...



External (I/O) interrupt handler (to me: HandleInt)
	Which interrupt (interrupt field in Cause reg)
	(for us: interrupt 0 is clock, 1 keyboard, 2 display)
	Call specific interrupt handler (xxx, KB_handler, DP_handler)
	Jump back to main exception handler

DP_handler (print char if can)
	(Re-)check display status (MIPS: memory-mapped)
	If putqueue not empty, print char
	Return to external interrupt handler

Back to hardware...

MIPS Exception Registers
------------------------

Show picture of CPU, CO, CI, Memory, I/O.

Kernel Register 0
	GPR $26 nicknamed $k0
	Kernel can trash between any two user instructions

Kernel Register 1
	GPR $27 nicknamed $k1
	Like $k0

The rest are coprocessor 0 registers.

To read  c0 reg $14 use:  mfc0 .., $14  (move from coprocessor 0)
To write c0 reg $14 use:  mtc0 .., $14  (...  to   ...)


Exception Program Counter (EPC)

	Coprocessor 0 reg $14

	PC of instruction causing exception 
		loaded on an exception
		"the return address"


Cause Register

	Coprocessor 0 reg $13

	bits	size	field
	----	----	-----
	31..16  16	IGNORE
	15..10	 6	interrupt
	9..8	 2	software_interrupt
	7..6	 2	ZERO
	5..2	 4	exception_code
	1..0	 2	ZERO

	interrupt || software_interrupt give seven interrupt-pending bits

	exception_codes
	---------------
	  0			external interrupt
	  1-7			IGNORE
	  8			syscall exception
	  9-12			IGNORE
	  13-15			RESERVED
	       
LSB HW interrupt is used for clock	interrupt[0] = cause[10]
	then		     keyboard	interrupt[1] = cause[11]
			     display	interrupt[2] = cause[12]

Says what interrupts are pending.


Status Register

	Coprocessor 0 reg $12

	bits	size	field
	----	----	-----
	31..16	16	IGNORE
	15..10	 5	hw_interrupt_mask
	9..8	 2	sw_interrupt_mask
	7..6	 2	ZERO
	5	 1	mode_old
	4	 1	interrupt_enable_old
	3	 1	mode_previous
	2	 1	interrupt_enable_previous
	1	 1	mode_current
	0	 1	interrupt_enable_current


Like w/ Cause:
hw-interrupt is used for     clock	interrupt[0] = cause[10]
	then		     keyboard	interrupt[1] = cause[11]
			     display	interrupt[2] = cause[12]

        ----ignore---- IIII IISS ZZEE EEZZ
	mask    1 .. 1 1111 0111 1111 1111
	0x        ffff	  f    7    f    f

Want to disable keyboard interrupts (called "maskable interrupt")

	mfc0	$5, $12
	andi	$5, $5, 0xffffff7ff	# Turn off keyboard interrupts
	mtc0	$5, $12

See GetQueueFull


Mode/interrupt_enable
		mode_* = 0 ==> kernel
		mode_* = 1 ==> user

		interrupt_enable_* = 0 ==> interrupts disabled
		interrupt_enable_* = 1 ==> interrupts ensabled

	On exception (and in parallel):
	   0 --> mode_current --> mode_previous --> mode_old
	   0 --> interrupt_enable_current --> <similarly>

	On instruction (return from exception) instruction:
	   mode_current <-- mode_previous <-- mode_old <-- ??
	   interrupt_enable_current <-- <similarly>

	A three-level stack!


Reference:

%T MIPS R2000 RISC Architecture
%A Gerry Kane
%I Prentice-Hall
%C Englewood Cliffs, NJ
%D 1987

See Chapter 5 
pp. 1-12 (intro to exceptions), 
p. 17 (external interrupts), and
p. 21 (syscall)

1987 edition is much cleaner than 1992 edition


On Exception HW does:

hardware does the following:
 1. sets state giving cause of exception
    Cause register -- coprocessor C0, register 13

      32 bit register, bits 6..2 (5 bits) specify the type
      of the exception, called the ExcCode.

      Page 316 gives the mapping of encodings to causes
      examples:
         00000  (0)  Interrupt
         00100  (4)  load from an illegal address
         01000  (8)  syscall instruction
         01100  (12) arithmetic overflow

 2. changes to kernel mode, saving the previous mode -- for dangerous work ahead
    in a hardware stack (3 levels deep)

    The mode is saved in the Status register.
    coprocessor C0, register 12

    defined in the processor's architecture are 2 modes,
       user -- the mode that user programs run under.
               certain instructions are not available
       kernel -- the operating system mode.  Allows the OS
               to retain control over "vital" system aspects.
               All instructions are available.

 3. disables further interrupts -- to prevent infinite loop
 4. saves current PC -- so able to resume previously-running program

    coprocessor C0, register 14, called Exception Program counter.

    Gives return address in user program. Where to return to
    when done handling the exception.

 5. jumps to hardwired address 0x8000 0080.
    This is where the exception handler code is.


Before we do the exception hander...


Jump Tables
-----------

A clever mechanism for doing something like a CASE statement.
A jump to one of many locations.


   keep a table of addresses (case1, case2, and case3):

   JumpTable:  .word case0
               .word case1
               .word case2


    sll  $8, $8, 2          # case number shifted left 2 bits
                            # (need a word offset into table, not byte)
    lw   $9, JumpTable($8)  # load address into $9
    jr   $9                 # jump to address contained in $9

    .
    .
    .

 case0:   #code for case0 here
    .
    .
    .
 case1:   #code for case1 here
    .
    .
    .
 case2:   #code for case2 here


  (Note that the cases don't have to go in any specific order.)



Addressing mode:          label($rb)
     Effective address is gotten by    label + ($rb)

     label doesn't fit into 16 bit displacement field of load/store
     instruction.

    MAL->TAL synthesis of this must be something like:
         la  $1, label
         add $1, $1, $rb
     then use 0($1) as addressing mode in load/store  instruction.




***********************************************
GO OVER EXCEPTION HANDLER (KERNEL) LINE BY LINE
***********************************************

1. Use Interrupt Kernel Structure Handout

2. Statically go through Kernel.

3. Dynamically follow putc syscall

Before:

cp0         bits        543210
---         ----        ------
$12  Status all-enabled ..xx11   "11" means user mode & interrupts enabled
$13  Cause  all-enabled CCCCxx   "CCCC" for ExcCode
$14  EPC

User code:

li $2, 11
move $4, 'x'
syscall


After exception:

cp0         bits        543210
---         ----        ------
$12  Status all-enabled ..1100   "00" means system mode & interrupts disabled
$13  Cause  all-enabled 1000xx   "CCCC" for ExcCode
$14  EPC    <address of syscall>

4. Dynamically go through display interrupt, ExcCode = 0

5. OPTIONALLY dynamically go through getc syscall

li $2, 12
syscall
move  .., $2 


Different architectures do exception differently,
but it is a variation on a common theme
-------------------------------------------------

	E.g., instead of jumping to specific address
	jump to address specified in a special register
	jump to address specified at a specific address (memory indirect)
	let address by modified by a few bits of the cause
	(hardware "vectors" interrupts)


Multiple interrupts
-------------------

So far
	run user program
	interrupt
	generation exception
	exception handler deals with interrupt
	resume user program

Q: What happens if multiple interrupt (and traps) arrive simultaneously?

A: Have priorities in HW / SW
	Handle highest-priority interrupt first
	("equal" priority interupts must be handled is some order)
	Give higher priority
		more serious (e.g., power failing)
		can't wait long (e.g., rotating disk)

Q: What happens if an interrupt arrives while an interrupt is being serviced?

Poor A: Make it wait until done with first interrupt

	But how do you prevent it from causing an exception?

	May be a bad idea for higher priority interrupts

Better A: Make (most of) exception handler re-entrant
	Allow higher-priority exceptions

Basic Idea
	Initial exception disables all interrupts
	Exception handler (EH) determines exception's priority
	EH then saves important state that could be clobbered
	if higher priority interrupt occurs (most important: EPC)
	EH re-enables higher-priority interrupts
	Higher-priority interrupts may or may not cause an exceptions
	This EH eventually finishes

For MIPS
	Status register's interrupt_enable bit is reset by exception
	(with current and previous moved to previous and old)
	A "master circuit breaker"
	Status register's 7b interrupt_mask field allows five levels
	of HW and two SW to be masked (ignored)


Processes and Multiprogramming
------------------------------

OS often has one exception handler called the "kernel"

A program running is called a "process" (or task)

A process's state is
	its memory (include stack)
	its regular registers (GPRs and FPRs)
	its PC and other control registers
	some OS memory (e.g., info and buffer for open files)

On an exception, the CPU jumps into the kernel

The kernel will eventually resume the user process

If the user process ask of an I/O (disk read), the kernel schedules it,
and then both often have nothing to for a long time (20 ms = 2M instructions)

Why not run another user program?
	Called multiprogramming or multitasking
		
To create the illusion of running processes concurrently,
	Also (context) switch after a time quantum (e.g., 2 ms or
	200K instructions)
	Check on clock interrupts

Multiprogramming on uniprocessor != multiprocessing on multiprocessor.

<!--#include virtual="style4.html" -->
