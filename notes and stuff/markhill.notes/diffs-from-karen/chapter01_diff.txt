1,4c1
< <html>
< <head>
< <title> Lecture notes - Chapter 1 - Some basics.</title>
< </head>
---
> <!--#include virtual="style1.html" -->
6,7c3,4
< <BODY>
< <h1> Chapter 1 -- Some basics</h1>
---
> Lecture Notes for
> Chapter 1 -- Introduction <!-- EDIT CHAPTER INFO -->
9c6
< <pre>
---
> <!--#include virtual="style2.html" -->
10a8,147
> Tuesday, August 28, 2001 <!-- EDIT LAST UPDATE DATE -->
> 
> <!--#include virtual="style3.html" -->
> 
> </PRE><b>NOT YET UPDATED FOR FALL 2003</b><PRE>
> 
> Moore's Law
> -----------
>    Q: What do the following intervals have in common?
>       0-2001
>       2002-2003
> 
> 
>    An Aside [WIRED Infoporn June 2001 p. 88]
> 
>        Feature    Old System            2001 System
>        -------    ----------            -----------
> 
>        ROM        1969 Apollo LEM       Rocket the Wonder Dog
>                   48 KB                 256 KB
> 
>        FP op/s    1985 Cray-2           Hello Kitty PC
>                   1 GFLOPS              1.8 GFLOPS
> 
>        Clock      1991 Space Shuttle    Mercedes-Benz S-500
>        Speed      1 MHz                 100 MHz
> 
> 
>    Why are things so exciting?
> 
>    Computer power has been doubling repeatedly every 1.5-2 year!
> 
>    Popularly called "Moore's Law"
> 
>    Actual Moore Law predicts that the number of transisors per chip
>    doubles every 18 months for a compound annual growth rate of 60%.
> 
> 
>    Absurd Example:
> 
>       Base Annual Salary: $16
>       Growth Rate:        60%
> 
>       Year   Salary          Comment
>       ----   ------          -------
>         0      16              Base
> 	3      64              Still live at home
>        15     $16K             Buy car
>        24    $100K             Buy house
>        36    $300M             ???
> 
>        But this has happened for transistors from the early 1960s
>        to the early 2000s!
> 
>    Will continue but rate may change
> 
>    How to spend transistors to get faster computers?
> 
>    What will faster and cheaper future computers be used for?
> 
> 
> ADMINISTRATIVE STUFF:
> 
> introduce self
>   name on board
> 
> introduce course
>   students work hard for the 4 credits
>   starts fast -- many homeworks
> 
> 
> goals for course:
> 	use applications 	ride in car
> 	HLL programming		drive car
> 	this course		a look under hood
> 
> 	why?			less vulnerable when HLL breaks
> 				write compiler or system SW
> 				build computers
> 
> Example 1:
> 
> 	int a, b, csquared;
> 	...
> 	a = 30000;
> 	b = 40000;
> 	csquared = a*a + b*b;
> 	c = sqrt(csquared);
> 
> Results should be 50000.
> 
> But get:  "Error: sqrt called with negative number."
> 
> Insert: printf("%d\n", csquared);
> 
> Prints: -1794967296
> 
> Q: Why not 50000*50000 = 2,500,000,000?
> 
> A: Max integer on most current machines is 2,147,483,647 = 2^31 - 1
>    2,500,000,000 > 2,147,483,647
> 
> Q: Why -1,794,967,296?
> 
> A: 2,500,000,000 - 2^32 = -1,794,967,296
>    By the end of this class this will make sense!!!
> 
> 	We start with HLL like Java
> 	and move down toward machines
> 
> 	Can be bizarre until you "get it"
> 
> 
> Example 2: Y2K Problem
> 
> In many computer programs year 1999 + 1 = 1900 not 2000.
> 
> Why? Many old programs only store the last two decimal digits: 99 and 00.
> 
> Why is this a problem? Is your younger sister born in 1985 eligible to
> get a drivers licence in 2001:
> 
> 	if (currentyear - birthyear >= 16 ) { /* get license */
> 
> With Y2K, this could evaluate to 01 - 85 = -84 < 16 ==> no license
> 
> Q: But why is it so hard to find these cases?
> 
> A: It depends on data and instruction representation that this course teaches.
> 
>    This course will teach you about it.
> 
> 
> 
> 
> 
> 
> GO OVER WEB PAGE IN DETAIL.
> 
> 
14d150
< 
16,18c152,154
<      Levels of Abstraction
<      hierarchy
<      models
---
>      Levels of Abstraction -- simplify -- e.g., map or computer memory
>      models -- add new ideas to understand -- route or linked list
>      hierarchy -- models on models
26,27c162
< 
<      example: the levels used in the design of a computer
---
>      example: design of a computer
34,35d168
< 	  #1 is the lowest (or bottom) level
< 	  #5 is the highest (or top) and most abstract level 
37,38c170,177
<   A diagram showing an interpretation of the various levels of
<   a computer system hardware design, where the diagram is not complete.
---
> 			computer system
> 
> 
> 
> 	  CPU            memory           I/O stuff
> 
> 
> 
40,84c179
<                  computer system
<                         |
<         ----------------------------------------------
<         |                              |             |
<        CPU                         memory system     I/O system
<     (processor)                        |
<         |                              |
<   -------------------               ----------------
<   |          |  ... |               |     |        |
<  registers  ALU  control          I-cache D-cache  main memory 
<              |   hardware
<              |
<      ------------------------------------------
<      |          |           |         ...     |
<   encoder    multiplexer  flip flop         adder
<                   |
<         -----------------------------
<         |        |         ...      |
<      nand gate  not gate          pass gate 
<                    |
<           ---------------------------
<           |                ...      |
<        CMOS p-type               CMOS n-type
<         transistor                transistor
< 
< 
< TOP-DOWN vs. BOTTOM-UP design
<   We can do our design starting at either end.  It makes no sense
<   to start in the middle.  In practice, designers always start
<   at the top.  After initial design, a bottom-up effort implements
<   known/common lowest level, and works up the hierarchy.  The design
<   changes through iterations; a change in one aspect of one level
<   causes changes in other levels.
< 
< 
<   another example:  software levels of abstraction
<     writing a large program:  >10,000 lines of code
<     TOP-DOWN:
<       divide into modules, design each module separately.
<       define procedures (functions, methods) that accomplish a task.
<       specify interfaces (parameters, arguments) for the procedures.
< 
<       the implementation of a function is independent of
<       its interface specification!  it is a different level
<       in the abstraction of program design.
---
>                         components
88,92c183,216
< the "big picture" -- a computer with software running on it.
< 
<      HLL (high level language)                         computer
<      Pascal, C, Fortran  .  .  .  .  .  .  .  .  .     hardware
<        Java
---
> 
>    	                gates
> 
> 
> 
>    	                transistors
> 
> 
>      discuss TOP-DOWN vs. BOTTOM-UP design
> 
> 
> 
> 
>      another example:  software levels of abstraction
>        writing a large program -- >10,000 lines of code
>        TOP-DOWN:
>        divide into modules, design each module separately.
>        define procedures (functions) that accomplish a task.
>        specify interfaces (parameters) for the procedures.
> 
> KEY CONCEPT:
>        the implementation of a function is independent of
>        its interface specification!  it is a different level
>        in the abstraction of program design.
> 
> 
>     the "big picture" -- a computer with software running on it.
> 
> 
> 
>       HLL                                               computer
>       Pascal, C, Fortran                                hardware
>       C++, Java
> 
99,250c223,348
<     what is machine language?
< 	binary sequences (lots of 1's and 0's in a very specific order)
< 	    interpreted by computer as instructions.
< 	not very human readable.
< 
<     to help the situation, introduce assembly language --
< 	a more human readable form of machine language.
< 	uses MNEMONICS for the instruction type, and operands
< 	BUT, now we need something to translate assembly language
< 	     to machine language:  an ASSEMBLER
< 
< 	     an example assembly language instruction might be something like:
< 	       add  AA, BB, CC
< 	     
< 	     "add" is the mnemonic or opcode (operation code)
< 	     AA, BB, and CC are the operands, the variables used in
< 		 the instruction.
<    
<     lastly, if we had a program that translated HLL programs
< 	to assembly language, then we'd have it made.
< 	a COMPILER does this.
< 
<    Here is an example of these levels within the hierarchy.
<    This example was provided by Prof. James Larus.
<    (You do not need to understand it.)
< 
< 
<         -------------------------------------------
<         sum.c   (the HLL version)
<         -------------------------------------------
< 
<         #include <stdio.h>
< 
<         int
<         main (int argc, char *argv[])
<         {
<           int i;
<           int sum = 0;
< 
<           for (i = 0; i <= 100; i++) sum += i * i;
<           printf ("The sum from 0 .. 100 is %d\n", sum);
<         }
< 
<         -------------------------------------------
<         sum.s   (the assembly language version)
<         -------------------------------------------
< 	        .text
< 	        .align	2
< 	        .globl	main
< 	        .ent	main 2
<         main:
< 	        subu	$sp, 32
< 	        sw	$31, 20($sp)
< 	        sd	$4, 32($sp)
< 	        sw	$0, 24($sp)
< 	        sw	$0, 28($sp)
<         loop:
< 	        lw	$14, 28($sp)
< 	        mul	$15, $14, $14
< 	        lw	$24, 24($sp)
< 	        addu	$25, $24, $15
< 	        sw	$25, 24($sp)
< 	        addu	$8, $14, 1
< 	        sw	$8, 28($sp)
< 	        ble	$8, 100, loop
< 	        la	$4, str
< 	        lw	$5, 24($sp)
< 	        jal	printf
< 	        move	$2, $0
< 	        lw	$31, 20($sp)
< 	        addu	$sp, 32
< 	        j	$31
< 	        .end	main
< 
< 	        .data
< 	        .align	0
<         str:
< 	        .asciiz	"The sum from 0 .. 100 is %d\n"
<         
< 
<         -------------------------------------------
<         sum.nolabels
<         -------------------------------------------
< 
<         addiu	sp,sp,-32
<         sw	ra,20(sp)
<         sw	a0,32(sp)
<         sw	a1,36(sp)
<         sw	zero,24(sp)
<         sw	zero,28(sp)
<         lw	t6,28(sp)
<         lw	t8,24(sp)
<         multu	t6,t6
<         addiu	t0,t6,1
<         slti	at,t0,101
<         sw	t0,28(sp)
<         mflo	t7
<         addu	t9,t8,t7
<         bne	at,zero,-9
<         sw	t9,24(sp)
<         lui	a0,4096
<         lw	a1,24(sp)
<         jal	1048812
<         addiu	a0,a0,1072
<         lw	ra,20(sp)
<         addiu	sp,sp,32
<         jr	ra
<         move	v0,zero
< 
<         -------------------------------------------
<         sum.machine_lang  (the machine language version)
<         -------------------------------------------
< 
<         00100111101111011111111111100000
<         10101111101111110000000000010100
<         10101111101001000000000000100000
<         10101111101001010000000000100100
<         10101111101000000000000000011000
<         10101111101000000000000000011100
<         10001111101011100000000000011100
<         10001111101110000000000000011000
<         00000001110011100000000000011001
<         00100101110010000000000000000001
<         00101001000000010000000001100101
<         10101111101010000000000000011100
<         00000000000000000111100000010010
<         00000011000011111100100000100001
<         00010100001000001111111111110111
<         10101111101110010000000000011000
<         00111100000001000001000000000000
<         10001111101001010000000000011000
<         00001100000100000000000011101100
<         00100100100001000000010000110000
<         10001111101111110000000000010100
<         00100111101111010000000000100000
<         00000011111000000000000000001000
<         00000000000000000001000000100001
< 
< 
< 
< 
<     the complete picture:
< 
< 
<              -----------                  ------------
<     HLL ---> | compiler|---> assembly --->| assembler|--->machine
<              -----------     language     ------------    language
< 
< 
<    (least detailed)                                     (most detailed)
<    (most abstract)                                     (least abstract)
<    (top level)                                          (bottom level)
---
> 
>     Example provided by Prof. James Larus (you don't have to understand
>     this now)
> 
> 
> -------------------------------------------
> sum.c
> -------------------------------------------
> 
> #include &lt;stdio.h&gt; <!-- really: #include <stdio.h> -->
> 
> int
> main (int argc, char *argv[])
> {
>   int i;
>   int sum = 0;
> 
>   for (i = 0; i <= 100; i++) sum += i * i;
>   printf ("The sum from 0 .. 100 is %d\n", sum);
> }
> 
> 
> -------------------------------------------
> sum.s
> -------------------------------------------
> 	.text
> 	.align	2
> 	.globl	main
> 	.ent	main 2
> main:
> 	subu	$sp, 32
> 	sw	$31, 20($sp)
> 	sd	$4, 32($sp)
> 	sw	$0, 24($sp)
> 	sw	$0, 28($sp)
> loop:
> 	lw	$14, 28($sp)
> 	mul	$15, $14, $14
> 	lw	$24, 24($sp)
> 	addu	$25, $24, $15
> 	sw	$25, 24($sp)
> 	addu	$8, $14, 1
> 	sw	$8, 28($sp)
> 	ble	$8, 100, loop
> 	la	$4, str
> 	lw	$5, 24($sp)
> 	jal	printf
> 	move	$2, $0
> 	lw	$31, 20($sp)
> 	addu	$sp, 32
> 	j	$31
> 	.end	main
> 
> 	.data
> 	.align	0
> str:
> 	.asciiz	"The sum from 0 .. 100 is %d\n"
> 
> 
> -------------------------------------------
> sum.nolabels
> -------------------------------------------
> 
> addiu	sp,sp,-32
> sw	ra,20(sp)
> sw	a0,32(sp)
> sw	a1,36(sp)
> sw	zero,24(sp)
> sw	zero,28(sp)
> lw	t6,28(sp)
> lw	t8,24(sp)
> multu	t6,t6
> addiu	t0,t6,1
> slti	at,t0,101
> sw	t0,28(sp)
> mflo	t7
> addu	t9,t8,t7
> bne	at,zero,-9
> sw	t9,24(sp)
> lui	a0,4096
> lw	a1,24(sp)
> jal	1048812
> addiu	a0,a0,1072
> lw	ra,20(sp)
> addiu	sp,sp,32
> jr	ra
> move	v0,zero
> 
> -------------------------------------------
> sum.machine_lang
> -------------------------------------------
> 
> 00100111101111011111111111100000
> 10101111101111110000000000010100
> 10101111101001000000000000100000
> 10101111101001010000000000100100
> 10101111101000000000000000011000
> 10101111101000000000000000011100
> 10001111101011100000000000011100
> 10001111101110000000000000011000
> 00000001110011100000000000011001
> 00100101110010000000000000000001
> 00101001000000010000000001100101
> 10101111101010000000000000011100
> 00000000000000000111100000010010
> 00000011000011111100100000100001
> 00010100001000001111111111110111
> 10101111101110010000000000011000
> 00111100000001000001000000000000
> 10001111101001010000000000011000
> 00001100000100000000000011101100
> 00100100100001000000010000110000
> 10001111101111110000000000010100
> 00100111101111010000000000100000
> 00000011111000000000000000001000
> 00000000000000000001000000100001
> 
> 
>     complete picture:
> 
> 
> 
>     HLL        compiler      assembly       assembler     machine
> 			     language                     language
> 
>     width*length             mult f1, f2, f3             0101001...
252a351,367
>     compiler - translates HLL in assembly language (CS 536)
> 
>     assembly language
> 	give operation first with MNEUMONIC
> 	   * operation (e.g., *)
> 	   * operand types (e.g., integers)
> 
> 	give operand locations
> 	   * often output/result operand first
> 	   * often two input operands last
> 
>     assembler - translates assembly language to machine language
>       * all 0' and 1's.
>       * for both instructions and data
> 
> 
> 
258a374
> 
264,266d379
< 
< 
< 
268,270c381,382
< 
<    the relationship between hardware (stuff you can touch)
< 		   and  software (programs, code)
---
>    the relation between hardware (stuff you can touch)
> 		   and  software (programs)
273c385
<    I can design a computer that has hardware which directly executes
---
>    I can design a computer that has hardware which executes
275,276c387
<      For example,  a computer that directly executes Pascal.
<        (The input to the computer is source code.)
---
>      For example,  a computer that directly executes Java.
285c396
<    2.  Usability of the machine.  Not everyone wants a Pascal
---
>    2.  Usability of the machine.  Not everyone wants a Java
287a399,403
> 
>    Furthermore, the Church-Turing Thesis reveals to us that
>    all (reasonable) computers CAN compute the same things,
>    so we can concentrate on computing them WELL.
> 
289a406,423
> What is the difference between a comptuer architecture and a
> particular machine?
> Machines:
> 	A Dell PC with an Intel Pentium IV
> 	A Compaq PC with AMD Athlon processor
> 	A Gateway PC with a Intel Pentium III microprocessor
> 
> Architecure: IA-32 or x86 -- all run the same software
> 	(Some special instructions for graphics are different)
> 
> Architecture we will use is
> 	MIPS R2000 (Kane, MIPS RISC Architecture book, on reserve)
> 	representative of RISC architectures
> 	popular, simpler than many architectures (e.g., x86).
> 
> 	Used by many video game manufactures
> 	Often "embedded"
> 	Similar to Sun Sparc and IBM PowerPC.
293,295c427
< those programs directly.  A simulator is providing that
< illusion for you.  It makes it appear as if you are running code
< directly on a machine.
---
> those programs directly.
300d431
<    hll --->    SAL --->    MAL  --->  TAL
301a433
>    HLL ------> SAL ------> MAL ------> TAL
303,306d434
< We assume that you know a hll (high level language, like C++, C, Java
< Pascal, Fortran).  From that, we can give you SAL.
< Later in the semester, you will learn MAL and TAL.
< Programs will be written in both SAL and MAL.
307a436,437
> we assume that you know a HLL.  From that, we can give you
> SAL.  Later in the semester, you will learn MAL and TAL.
309c439,440
< hll, SAL, and MAL are each abstractions.
---
> 
> HLL, SAL, and MAL are each abstractions.
311c442
< TAL happens to correspond to a real (manufactured) architecture.
---
> TAL happens to be a real (manufactured) architecture.
321,329c452,456
<    ------------             ----------
<    | CPU      | <---------> | memory |
<    |processor |             |        |
<    ------------      |      ----------
<                      |
<                      |
<                   -------
< 	          | I/O |
<                   -------
---
> 
>      CPU -------+------- memory
>                 |
>                 |
> 	       I/O
335,336d461
<        CPU stands for central processing unit
<        CPU and processor are synonyms
340,347d464
< The STORED PROGRAM COMPUTER concept
<      We use a memory to save our program, instead of actually
<      setting up the hardware (buttons/switches/pluggable wires) to
<      know what to do.
< 
<      This was a big deal in the 1940s!  It allowed programs to be
<      permanently saved on other media, and then used I/O devices to
<      place the program in the computer memory.
349,351c466,467
< 
< On the interaction between processor and memory.
<     to execute an instruction, the processor must be able to
---
> interaction between CPU and memory.
>     to execute an instruction, the CPU must be able to
365c481
<     where?       a label specifies a unique place (a location) in memory.
---
>     where?       a label specifies a unique place in memory.
369,370c485,486
<     read:   processor specifies an address and a read operation
< 	    memory responds with the contents at the address
---
>     read:   CPU specifies an address and a read operation
> 	    memory responds with the contents of the address
372c488
<     write:  processor specifies an address, data to be stored, and
---
>     write:  CPU specifies an address, data to be stored, and
377a494,495
> Ancient Chinese Philosopher:  A journey of a 1000 miles begins
> 			      with a single step
379,380c497,501
< for discussion:   how (most) processors operate WRT the execution
< 		  of instructions.
---
> For computers
> 	journey -- execute program
> 	step -- instruction
> 		   make some progress
> 		   specific next step--next instruction
384,388c505
< 	    mult   aa, bb, cc
< 	     ^         ^
< 	     |         |____ list of operands (the variables)
< 	     |
< 	     |_____ the instruction's mnemonic (short name for instruction)
---
> 	    mult   a, b, c
391,393c508,509
<      Instructions and operands are stored in memory (in a special
<        machine code format, not shown in this example).
<      Before the instruction can be used by the CPU, the instruction must
---
>      instructions and operands are stored in memory.
>      before they can be used by the CPU, they must
398c514
< 	  questions for later: which instruction, what address?
---
> 	  questions for later: which instruction, what address
405c521
<           OPERANDS ARE bb AND cc
---
>           OPERANDS ARE b AND c
407c523
< 	  MULTIPLY bb AND cc TOGETHER
---
> 	  MULTIPLY b AND c TOGETHER
409c525
< 	  RESULT GOES INTO VARIABLE aa
---
> 	  RESULT GOES INTO VARIABLE a
415,418c531
<      except for control instructions, execute instructions sequentially
< 
<      The processor must keep track of which instruction is to be
<      executed.
---
>      except for branch instructions, execute instructions sequentially
420,423c533,534
<      It does this by the use of an extra variable contained within
<      and maintained by the processor, called a PROGRAM COUNTER or PC.
<      The contents of the PC is the address of the next instruction to
<      be executed.
---
>      the CPU must keep track of which instruction is to be
>      executed
425c536,539
<      Intel calls their version of the PC the IP (Instruction Pointer).
---
>      it does this by the use of an extra variable contained within
>      and maintained by the CPU, called a PROGRAM COUNTER, or PC
>      the contents of the variable is the address of the next
>      instruction to be executed.
428c542
<      Revise the CPU steps given above:
---
>      modify the above CPU steps:
441c555
<   control instructions.  
---
>   branch instructions.  
446,447c560,561
<   Control Instructions example
<        beq x, y, label
---
>   branch instructions:
>        example:   beq x, y, label
449,453d562
<   A control instruction is one that explicitly modifies the PC
<   other than to update it to point to the next instruction.
<   This is how we accomplish a "goto" type of instruction.
<   This category of instructions are most often called a branch
<   or a jump.
458,459c567,568
<      (its a BEQ instruction, and there are 3 operands)
<   4. load operands (x and y)
---
>      (its a BEQ instruction)
>   4. fetch operands (x and y)
462,465d570
<      (if not equal, do nothing more for this instruction)
< 
< 
< 
481c586
< and to have a way of knowing when the program is done, so the
---
> and to have a way of knowing when the program is done, and the
485,487c590,592
< This cycle of steps is very important -- it forms the basis for
< understanding how a computer operates.  This cycle of steps
< is termed the INSTRUCTION FETCH and EXECUTE CYCLE.
---
> the cycle of steps is very important -- it forms the basis for
> understanding how a computer operates.  The cycle of steps
> is termed the INSTRUCTION FETCH/EXECUTE CYCLE.
489c594,639
< 
---
> 
> Put it all Together: The Cardboard Computer
> 
> 	PC: I1
> 
> 	I1: add x1, x1, x2
> 	I2: sub x3, x3, x4
> 	I3: add x5, x5, x1
> 	I4: bne x1, x3, I1
> 	I5: HALT
> 
> 	X1:  0
> 	X2: 10
> 	X3: 30
> 	X4:  5
> 	X5:  0
> 
> Master Control Loop:
> 
> top:
> 	Fetch Instr
> 	Increment PC
> 	Decode Instr
> 	Fetch Operands
> 	Execute Operation
> 	Store Results
> 	goto top
> 
> 
> Key concepts from chapter:
> -------------------------
> 
> Abstraction -- hides details
>    ML --> (TAL --> MAL --> SAL) --> HLL
> 
> Computer architecture vs. implementation
> 	x86 vs. 486
> 
> Computer parts
> 	CPU, Memory, I/O
> 
> Instructions
> 	one step at a time
> 	stored in memory
> 	operand in memory
> 	must specify next instruction
492,537c642
< There are two different methods used in architectures for
< defining control instructions and how they work.  They
< have equivalent functionality, meaning that both methods
< can accomplish the same things.  The code appears a bit
< different depending on the method.
< 
< The two methods:
< 1.  decision based on comparison of operands
<   This is the method described above.  
<   
<   It is used by the MIPS architecture, and the Alpha architecture.
< 
<   Operands (included in the instruction) are compared.  Based
<   on that comparison, the PC may be changed.
< 
< 2.  decision based on setting of condition codes
< 
<   The processor keeps and maintains another variable often called
<   a Condition Code Register or just the Condition Codes.
<   This variable contains information about the result generated
<   by an instruction.
<      The information indicates whether the result is positive,
<      zero, or negative.
< 
<   When the Condition Codes get updated varies from architecture to
<   architecture.  One easy-to-remember implementation has the update
<   done during step 6 of every instruction that does an arithmetic
<   type of operation.
< 
<   The control instruction then looks at the Condition Codes to base
<   a decision on whether or not to overwrite the PC.
< 
<   An example of an instruction (invented) might be
<        bpos  label
<   This instruction would overwrite the PC with the address implied
<   by the operand label if the Condition Codes indicated a positive
<   result.
< 
<   Note that the ordering of instructions (so that the intended one
<   sets the Condition Codes) becomes important with this method.
< 
<   It is used by the Intel IA-32 (x86 or Pentium) architecture.
<   The SPARC also has condition codes.  On the SPARC, there are 2 forms
<   of many arithmetic instructions.  One form sets condition codes based on
<   the result, the other form does not.
< </pre>
---
> <!--#include virtual="style4.html" -->
