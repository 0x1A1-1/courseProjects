<html>
<head>
<title> Lecture notes - Chapter 10 - Assembly</title>
</head>

<BODY>
<h1> Chapter 10 -- The Assembly Process</h1>

<pre>

THE ASSEMBLY PROCESS
--------------------

 -- a computer understands machine code
 -- people (and compilers) write assembly language

  assembly     -----------------       machine
  source  -->  |  assembler    | -->   code
  code         -----------------

an assembler is a program -- a very deterministic program --
  it translates each instruction to its machine code.



  In the past, there was a one-to-one correspondence between
  assembly language instructions and  machine language instructions.

  This is no longer the case.  Assemblers are now-a-days made more
  powerful, and can "rework" code.




MAL --> TAL
-----------

MAL -- the instructions accepted by the assembler
TAL -- a subset of MAL.  These are instructions that
	can be directly turned into machine code.

There are lots of MAL instructions that have no direct TAL
equivalent.  They will be translated (composed, synthesized) into
one or more TAL instructions.

How to determine whether an instruction is a TAL instruction or not:

   look in appendix C.  If the instruction is there, then
   it is a TAL instruction.


The assembler takes (non MIPS) MAL instructions and synthesizes
them with 1 or more MIPS instructions.

Some examples:
    mul $8, $17, $20
      becomes
    mult  $17, $20
    mflo  $8

    why?  32-bit multiplication produces a 64-bit result.
    To deal with this larger result, the MIPS architecture
    has 2 registers that hold results for integer multiplication and
    division.  They are called HI and LO.  Each is a 32 bit register.

    mult places the least significant 32 bits of its result
    into LO, and the most significant into HI.

    Then, more TAL instructions are needed to move data into or out
    of registers HI and LO:

    operation of mflo,  mtlo,  mfhi,  mthi
                 |||                  |||
                 ||-- register lo     ||- register hi
                 |--- from            |-- to
                 ---- move            --- move
	
	Data is moved into or out of register HI or LO.

	One operand is needed to tell where the data is coming from
	or going to.


  Integer division also uses register HI and LO, since it
  generates both a quotient and remainder as a result.

  MAL        div $rd, $rs, $rt

  becomes TAL    div  $rs, $rt
                 mflo $rd          # quotient in register LO

  and MAL    rem $rd, $rs, $rt

  becomes TAL    div  $rs, $rt
                 mfhi $rd          # remainder in register HI



  addressing modes do not exist in TAL!

    lw  $8, label
      becomes

    la  $8, label
    lw $8, 0($8)
      which becomes

    lui $8, 0xMSpart of label      # label represents an address
    ori $8, $8, 0xLSpart of label
    lw $8, 0($8)

      or
    lui $8, 0xMSpart of label
    lw $8, 0xLSpart of label($8)
           (this 2-instruction sequence only works if the most significant
	    bit of the LSpart of label is a 0)


  instructions with immediates are synthesized with other instructions

    add $sp, $sp, 4
      becomes
    addi $sp, $sp, 4

         because an add instruction requires 3 operands in registers.
	 addi has one operand that is immediate.

	 these instructions are classified as immediate instructions.
	 On the MIPS, they include:
	   addi, addiu, andi, lui, ori, xori


 add $12, $18  is expanded back out to be
   add $12, $12, $18



TAL implementation of I/O instructions:


putc $18     becomes

   li $2, 11         # MAL
   move $4, $18      # MAL
   syscall

   which becomes
          addi $2, $0, 11
	  add  $4, $18, $0
	  syscall



getc $11     becomes

   li $2, 12
   syscall
   move $11, $2

   which becomes
          addi $2, $0, 12
	  syscall
	  add  $11, $2, $0



puts $13     becomes

   li $2, 4
   move $4, $13
   syscall

   which becomes
          addi $2, $0, 4
	  add  $4, $13, $0
	  syscall



done         becomes

   li  $2, 10
   syscall

   which becomes
          addi $2, $0, 10
	  syscall




ASSEMBLY
---------
 the assembler's job is to 
   1. assign addresses
   2. generate machine code


 a modern assembler will
  -- on the fly, translate (synthesize) from the accepted assembly
     language to the instructions available in the architecture

  -- assign addresses

  -- generate machine code

  -- it generates an image of what memory must look like for the
     program to be executed.


 a simple assembler will make 2 complete passes over the data
 to complete this task.  
    pass 1:  create complete SYMBOL TABLE
	     generate machine code for instructions other than
	       branches, jumps, jal, la, etc. (those instructions
	       that rely on an address for their machine code).
    pass 2:  complete machine code for instructions that didn't get
	     finished in pass 1.

SYMBOL TABLE -- a table, listing address assignments (made by the assembler)
  for ALL labels

The assembler starts at the top of the source code program,
and SCANS.   It looks for
  -- directives   (.data  .text  .space  .word  .byte  .float )
  -- instructions

  IMPORTANT:
  there are separate memory spaces for data and instructions.
  the assembler allocates them IN SEQENTIAL ORDER as it scans
  through the source code program.

  the starting addresses are fixed -- ANY program will be assembled
  to have data and instructions that start at the same address.



EXAMPLE  (given in little endian order)
    .data
a1: .word 3
a2: .byte '\n'
a3: .space 5

       address     contents
     0x00001000    0x00000003
     0x00001004    0x??????0a
     0x00001008    0x????????
     0x0000100c    0x????????  (the 3 MSbytes are not part of the declaration)

  the assembler will align data to word addresses unless you specify
  otherwise!


simple example of machine code generation for simple instruction:
     assembly language:      addi  $8, $20, 15

                              ^     ^   ^    ^
			      |     |   |    |

			    opcode rt   rs  immediate

     machine code format
      31                      15             0
      -----------------------------------------
      | opcode |  rs  |  rt  |  immediate     |
      -----------------------------------------

       opcode is 6 bits -- it is defined to be 001000

       rs is 5 bits,    encoding of 20, 10100
       rt is 5 bits,    encoding of  8, 01000
			     
      so, the 32-bit instruction for addi $8, $20, 15  is
       001000 10100 01000 0000000000001111

       re-spaced:
       0010 0010 1000 1000 0000 0000 0000 1111
	 OR
     0x  2    2   8    8    0    0    0    f






AN EXAMPLE:

 .data
a1: .word 3
a2: .word 16:4
a3: .word 5

 .text
__start: la $6, a2              # MAL code fragment
loop:    lw $7, 4($6)
         mult $9, $10
         b loop
         done

SOLUTION:

    Symbol table
    symbol      address
    ---------------------
    a1         0040 0000
    a2         0040 0004
    a3         0040 0014
    __start    0080 0000
    loop       0080 0008



     memory map of data section
address     contents
	    hex          binary
0040 0000   0000 0003    0000 0000 0000 0000 0000 0000 0000 0011 
0040 0004   0000 0010    0000 0000 0000 0000 0000 0000 0001 0000
0040 0008   0000 0010    0000 0000 0000 0000 0000 0000 0001 0000
0040 000c   0000 0010    0000 0000 0000 0000 0000 0000 0001 0000
0040 0010   0000 0010    0000 0000 0000 0000 0000 0000 0001 0000
0040 0014   0000 0005    0000 0000 0000 0000 0000 0000 0000 0101



     translation to TAL code
 .text
__start: lui $6, 0x0040      # la $6, a2
         ori $6, $6, 0x0004
loop:    lw $7, 4($6)
         mult $9, $10
         beq $0, $0, loop    # b loop
         ori $2, $0, 10      # done
         syscall



     memory map of text section
address      contents
	     hex          binary
0080 0000    3c06 0040    0011 1100 0000 0110 0000 0000 0100 0000 (lui)
0080 0004    34c6 0004    0011 0100 1100 0110 0000 0000 0000 0100 (ori)
0080 0008    8cc7 0004    1000 1100 1100 0111 0000 0000 0000 0100 (lw)
0080 000c    012a 0018    0000 0001 0010 1010 0000 0000 0001 1000 (mult)
0080 0010    1000 fffd    0001 0000 0000 0000 1111 1111 1111 1101 (beq)
0080 0014    3402 000a    0011 0100 0000 0010 0000 0000 0000 1010 (ori)
0080 0018    0000 000c    0000 0000 0000 0000 0000 0000 0000 1100 (syscall)





EXPLANATION:

The assembler starts at the beginning of the ASCII source
code.  It scans for tokens, and takes action based on those
tokens.

---  .data
   A directive that tells the assembler that what will come next
   are to be placed in the data portion of memory.
---  a1:  
   A label.  Put it in the symbol table.  Assign an address.
   Assume that the program data starts at address 0x0080 0000.






branch offset computation.
    
    at execution time (for taken branch):
     contents of PC + sign extended offset field | 00 --> PC

     PC points to instruction after the beq when offset is added.

    
    at assembly time:

    byte offset = target addr - ( 4 + beq addr )

		= 00800008 - ( 00000004 + 00800010 )  (hex)



                    (ordered to give POSITIVE result)
		 0000 0000 1000 0000 0000 0000 0001 0100
	      -  0000 0000 1000 0000 0000 0000 0000 1000
	      ------------------------------------------
		 0000 0000 0000 0000 0000 0000 0000 1100 (byte offset)

		    (compute the additive inverse)
		 1111 1111 1111 1111 1111 1111 1111 0011
	       +                                       1
	       -----------------------------------------
		 1111 1111 1111 1111 1111 1111 1111 0100  (-12)


		 we have 16 bit offset field.
		 throw away least significant 2 bits
		   (they should always be 0, and they are added
		    back at execution time)

	 1111 1111 1111 1111 1111 1111 1111 0100 (byte offset)
	  becomes
	                  11 1111 1111 1111 01   (offset field)



jump target computation.

    at execution time:
     most significant 4 bits of PC || target field | 00 --> PC
					(26 bits)


    at assembly time, to get the target field:
	 take 32 bit target address,
	   eliminate least significant 2 bits (word address!)
	     eliminate most significant 4 bits

	 what remains is 26 bits, and it goes in the target field


   An example of machine code generated for a jump instruction:
      .
      .
      .
      j   L2
      .
      .
  L2: # another instruction here


     Assume that the j instruction is to be placed at address 0x0100acc0
     Assume that the assembler assigns address 0x0100ff04 for label L2

     Then, when the assembler is generating machine code for the j instruction,
     1.  The assembler checks that the most significant 4 bits of
         the address of the jump instruction is the same as the most
	 significant 4 bits of the address for the target (L2).
	    instruction address        0000 0001 0000 0000 (m.s. 16 bits)
	    L2 address                 0000 0001 0000 0000 (m.s. 16 bits)
	                               ^^^^
         These 4 bits ARE the same, so procede.
     2. Extract bits 27..2 of the target address for the machine code.
	    L2  0000 0001 0000 0000 1111 1111 0000 0100
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     3. The machine code for the j instruction:

          000010     0001 0000 0000 1111 1111 0000 01
	  op code       26-bit partial address

	  Given in hexadecimal:
          0000 1000 0100 0000 0011 1111 1100 0001
	  0x 0    8    4    0    3    f    c    1


  In the first step, if the address of the jump instruction and the
  target address differ in their 4 most significant bits, then the
  assembler must translate to different TAL code.

  One possible translation:
     
     j  L3     # assume j will be placed at address 0x0400 0088
     .
     .
     .
  L3:          # assume L3 is at address 0xab00 0040


    becomes
      la   $1, L3
      jr   $1

      which in TAL, would be

          lui  $1, 0xab00
	  ori  $1, $1, 0x0040
	  jr   $1
</pre>

<html>
<head>
<title> Lecture notes - Chapter 10 - assembly</title>
</head>

<BODY>
<h1> more on Chapter 10 -- assembly</h1>

<pre>



  getting to program execution
  ----------------------------

To eventually run (execute) a program, the following things
are done:
  1.  write source code
  2.  assemble source code, producing machine code
  3.  link and load machine code
  4.  set PC to point to address of first instruction within code.
      (This is a jump to the first instruction in the program)

We've talked about steps 1. and 2.


  linking and loading
  -------------------

Assembly just produces enough information about what goes where
in memory to make the code run.  It does not actually put the
stuff in memory.  Linking and loading puts all the stuff into 
memory at the right places.

WHAT goes into memory?
  the data is put into the correct locations
  the code is put into the correct locations

WHERE are the correct locations?

  Exactly where the assembler assigns them.

  For example,

  The data section starts at 0x00400000 in our simulator of 
  the MIPS RISC processor.

  So, if we had source code with,

    .data
    a1:  .word 15
    a2.  .word -2


    then the assembler needs to specify that memory will need to be
    initially set up with

    address        contents
    0x00400000     0000 0000 0000 0000 0000 0000 0000 1111
    0x00400004     1111 1111 1111 1111 1111 1111 1111 1110


  Like the data, the code needs to be placed starting at a specific
  location to make it work.





Here are some difficulties with this simplistic model.


Consider the case where the assembly language code is split
across 2 files.  EACH IS ASSEMBLED SEPARATELY.

file 1:  

         .data
         a1:  .word 15
         a2:  .word -2

         .text
         __start: la  $t0, a1
                  add  $t1, $t0, $s3
		  jal  proc5
                  done


file 2:  

         .data
         a3:  .word 0

         .text
         proc5:   lw   $t6, a1
                  sub  $t2, $t0, $s4
                  jr   $ra


Two problems with this
----------------------
 1.  Each file is assembled to start its data section and also its
     code section at the same location as the other file.

     a1 (in file1) is supposed to be placed at 0x00400000
     a3 (in file2) is supposed to be placed at 0x00400000

     __start (in file1) is placed at location 0x00800000
     proc5   (in file1) is placed at location 0x00800000





 2.  When assembling file 1, symbol proc5 is never defined
     (given an address).  That is because the label (symbol)
     is defined in file 2.  The address assigned to proc5
     is NEEDED to produce the machine code for the jal instruction
     in file 1.

     This same problem presents itself in the lw instruction
     in file 2.  The address assigned to a1 is unknown when
     assembling file 2.  This is because the symbol a1 is defined
     (and given and address) in file 1.


     The real problem here is that there are ABSOLUTE ADDRESSES
     needed to produce the machine code.



Solutions to the problems
-------------------------

1.  A really BAD solution that no one would ever implement.
    Define the problem away, by not allowing separate files to
    contain assembly language source code.

    A single program (all code and data) MUST be all in one file.

    Why is this bad?

2.  Allow the step of linking and loading to
    -- relocate pieces of data and code sections
    -- finish the machine code where symbols were left undefined

    To accomodate linking and loading, the information produced
    by the assembler must include:
      -> symbol table
      -> machine code that is finished
      -> list of all locations within the code that require
	 absolute addresses for their resolution.
      
      This last one is something new.




LINKING and LOADING
-------------------

  Have the assembler
   -> start both data and code sections at address 0, for all files.
   -> keep track of the size of every data and code section.
   -> keep track of all absolute addresses within the file.

  Linking and loading will:
   -> assign starting addresses for all data and code sections,
      based on their sizes.  The blocks of data and code go at
      non-overlapping locations.
   -> fix ALL absolute addresses in the code
   -> place the fixed-up code and data in memory at the locations
      assigned.

</pre>
