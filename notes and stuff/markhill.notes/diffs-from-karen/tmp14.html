<html>
<head>
<title> Lecture notes - Chapter 14 - Architectures</title>
</head>

<BODY>
<h1> Chapter 14 -- Architectures</h1>

<pre>

PERSPECTIVE ON ARCHITECTURE DESIGN
----------------------------------

Some factors in computer design:
   speed
       as fast as possible, of course
       dependent on technology and cost
   cost/price
       profit, non-profit, mass market, single use
   useablility
       shared/single user, size of machine, OS/software issues,
       power requirements, weight, portability
       depends on intended use!
   intended market
       mass market, scientific research, home use, multiple users,
       instructional, application specific
   technology




price/performance curve

       ^  |
 perf. |  |         x
          |           x          Want to be to the "left"  of these,
          |      x               to have higher performance for the
          |                      price.  "More bang for the buck."
          |    x   x
          _________________
		    
		    price ->




technology -- a perspective
----------

    electromechanical (1930) -- used mechanical relays

    vacuum tubes (1945)
      space requirement:  room
          Manchester Mark 1 (late 1940s)

    transistors
      discrete (late 1950s)
         space requirement:  a large cabinet to a room
	 Examples:
	    CDC 6600
	    B 5000
	    Atlas (?)
	    PDP 11/10

      SSI,    MSI (mid-late 1960s)
      1-10   10-100 transistors on a single chip
         space requirement:  a cabinet
	 Examples:
	   Cray 1
	   VAX 11/780

      LSI   (early 1970s)
      100-10,000 transistors on a single chip
         space requirement:  a board
	 Examples:

      VLSI  (late 1970s - today)
      >10,000 transistors on a single chip
         space requirement:  a chip, or chip set, board
	 Examples:
	    MIPS R2000 (the floating point was done on a second chip)
	    Intel 386 (~275,000 transistors)
	    Sparc
	    Pentium (~4 million transistors)
	    PowerPC (~4 million transistors)
	    PentiumPro (17 million transistors)




RISC vs. CISC
-------------

 RISC - Reduced Instruction Set Computer
   The term was first used to name a research architecture at
   Berkeley:  the RISC microprocessor.  It has come to (loosely) mean a
   single chip processor that has the following qualities:
     1. load/store architecture
     2. very few addressing modes
     3. simple instructions
     4. pipelined implementation
     5. small instruction set -- easily decoded instructions
     6. fixed-size instructions

 CISC - Complex Instruction Set Computer
   This term was coined to distinguish computers that were not RISC.
   It generally is applied to computers that have the following
   qualities:
     1. complex instructions
     2. large instruction set
     3. many addressing modes

difficulties with these terms

 - not precisely defined

 - term introduced/applied to earlier machines

 - "RISC" became a marketing tool


single chip constraint
----------------------

As technologies advanced, it became possible to put a processor
 on a single VLSI chip.  Designs became driven by how much
 (how many transistors) could go on the 1 chip.

 Why?  1.  The time it takes for an electrical signal to cross a
  chip are significantly less than the time for the signal to
  get driven off the chip to somewhere else.
       2.  The number of pins available was limited.

  So, the desire is to have as little interaction of the chip
   with the outside world as possible.  It cannot be eliminated,
   but it can be minimized.


The earliest of single processors on a chip had to carefully
pick and choose what went on the chip.  Cutting-edge designs
today can fit everything but second-level caches and
main memory on the chip.




how the world has changed
-------------------------
  earliest computers had their greatest difficulties in getting
  the hardware to work --
    technology difficulties 
       space requirements
       cooling requirements
  the software on these earliest computers was non-existant.

  given a working computer, scientists would jump through whatever
    hoops necessary to use it.


  as hardware has gotten (much) faster and cheaper, most attention has
  been diverted to software.
      OS
      compilers
      optimizers
      IPC (inter-process communication)








1 instruction at a time isn't enough.  The technology
isn't "keeping up."  So, do more than one instruction
at a time:

parallelism
-----------
  instruction level (ILP) -- pipelining
  superscalar -- more than one instruction at a time

  multis
  VLIW
  supercomputer

  WHICH OF THESE IS "BEST" and "FASTEST" DEPENDS ON WHAT PROGRAM
  IS BEING RUN -- THE INTENDED USEAGE.




on the 68000 Family
--------------------

- released in the late 1970's
- an early "processor on a chip"
- a lot of its limitations have to do with what could fit on a VLSI
  chip in the late 1970's

INSTRUCTIONS
 - a relatively simple set (like the MIPS) but NOT a load/store arch.
 - a two-address architecture
 - most instructions are specified in 16 bits -- fixed size.
 - tight encoding, it is difficult to distinguish opcode from operands,
   but the m.s. 4 bits are always part of the opcode.

 integer arithmetic
   different opcode for varying size data
   (add.b    add.w      add.l)
 logical
   different opcode for varying size data
 control instructions
   conditional branches, jumps
   (condition code mechanism used --  where most instructions
    had the effect of setting the condition codes)
 procedure mechanisms
   call and return instructions
 floating point ??
 decimal string
   arithmetic presuming representation of binary coded decimal



REGISTERS
  16 32-bit general purpose registers,
  only one is not general purpose (it is a stack pointer)
  the PC is not part of the general purpose registers

  the registers are divided up into two register files of 8,
    one is called the D (data) registers, and the other
    is called the A (address) registers.  This is a distinction
    similar to the CRAY 1.

  A7 is the stack pointer.



  diagram of register files:

         --------------         --------------
     A0  |            |     D0  |            |
         --------------         --------------
     A1  |            |     D1  |            |
         --------------         --------------
         |            |         |            |
         --------------         --------------
         |            |         |            |
         --------------         --------------
         |            |         |            |
         --------------         --------------
         |            |         |            |
         --------------         --------------
         |            |         |            |
         --------------         --------------
     A7  |            |     D7  |            |
         --------------         --------------


DATA TYPES
 byte
 word (16 bits)
 longword (32 bits)

 addresses are really their own data type.
   arithmetic on A registers is 32 bit arithmetic.  However,
   pin limitations on the VLSI chip required a reduced
   size of address.  Addresses that travel on/off chip are
   24 bits -- and the memory is byte-addressable.  So
   a 24-bit address specifies one of 16Mbyte memory locations.

each instruction operates on a fixed data type


OPERAND ACCESS

 the number of operands for each individual instruction
 is fixed

 like the VAX, the addressing mode of an operand does not
 depend on the instruction.  To simplify things, one of the
 operands (of a 2 operand instruction) must usually come from
 the registers.

 the number/type of addressing modes is much larger than
 the MIPS, but fewer than the VAX.


 the text has a detailed discussion of the 68000 addressing modes.
 READ IT!


PERFORMANCE
  ?, they got faster as new technologies got faster.

SIZE
  1 64-pin VLSI chip (a huge number of pins at that time)

  the 68020 had 88 pins




the Intel iAPX 86 (also correctly called the IA-32 (x86) Architecture
---------------------------------------------------------------------- 

History

     As technology improved over the years, there developed
     a race to get the first (usable) processors on a 
     single integrated circuit.

     When able to place approximately 10,000
     transistors on a single IC, then we have just about enough
     circuitry to put a (simple) processor on a this single IC.

     The Intel 8086 was Intel's entry in the race.  On the way to
     getting their processor out (on the market) as fast as
     possible, they made some unusual design decisions.

     Evolution
        1974    8080 8-bit architecture with 8-bit bus

	1978	8086 16 bit architecture w/ 16-bit bus 
	        (compatible with earlier 8085 chip set)
		
		8088 - like 8086, 16-bit architecture, but
		       only had an 8-bit (internal) bus
		selected for IBM PC -- golden handcuffs

	1980	8087 FPU

	1982	80286 24-bit weird addresses

	1985	80386 32b registers and addresses

	1989 80486, 1993 Pentium, 1995 Pentium Pro -- few changes

	1997	MMX (discuss later)

     On being "backward compatible"


Current implementations

    Pentium Pro and after

	Instruction decode translates machine code into "RISC OPS"
         	(like decoded MIPS instrns)
	Execution unit runs RISC OPS

	+ Backward compatiblity
	- Complex decoding
	+ execution unit as fast as RISC like MIPS



About the Pentium Architecture
------------------------------

 -- It is not a load/store architecture.

 -- The instruction set is huge!  We go over only a fraction of
    the instruction set.
	16bit, 32bit operations on memory and registers
	decoding nightmare: a single machine code instruction
	  can be from 1 to 17 bytes long w/ prefixes & postfixes
	But, mainline (most common) 386 instructions not terrible

 -- There are lots of restrictions on how instructions/operands are
    put together, but there is also an amazing amount of flexibility.


 Registers
 ---------
   
   The Intel architectures as a set just do not have enough registers
   to satisfy most assembly language programmers.  Still, the processors
   have been around for a LONG time, and they have a sufficient number
   of registers to do whatever is necessary.

   For our (mostly) general purpose use, we get

   32-bit      16-bit    8-bit             8-bit
			(high part of 16) (low part of 16)

    EAX         AX        AH                AL
    EBX         BX        BH                BL
    ECX         CX        CH                CL
    EDX         DX        DH                DL


    and

    EBP         BP
    ESI         SI
    EDI         DI
    ESP         SP

   There are a few more, but we won't use or discuss them.  They
   are only used for memory accessability in the segmented memory
   model.

   Note that it is unusual to be able to designate part
   of a register as an operand.  This evolved, due to the
   backward compatibility to previous processors that had
   16-bit registers.



   Using the registers:
     As an operand, just use the name (upper case and lower case both
     work interchangeably).

     EBP is a frame pointer.
     ESP is a stack pointer.



   ONE MORE REGISTER:
     Many bits used for controlling the action of the processor and
     setting state are in the register called EFLAGS.  This register
     contains the condition codes:

       OF  Overflow flag
       SF  Sign flag
       ZF  Zero flag
       PF  Parity flag
       CF  Carry flag

     The settings of these flags are checked in conditional control
     instructions.  Many instructions set one or more of the flags.

     The use of the EFLAGS register is implied (rather than explicit)
     in instructions.



 Accessing Memory
 ----------------

 There are 2 memory models supported in the Pentium architecture.
 (Actually it is the 486 and more recent models that support 2 models.)

 In both models, memory is accessed using an address.  It is the
 way that addresses are formed (within the processor) that differs
 in the 2 models.


 FLAT MEMORY MODEL

  -- The memory model that every one else uses.

  -- 

 SEGMENTED MEMORY MODEL

  -- Different parts of a program are assumed to be in their own,
     set-aside portions of memory.  These portions are called
     segments.

  -- An address is formed from 2 pieces:  a segment location and
     an offset within a segment.

     Note that each of these pieces can be shorter (contain fewer
     bits) than a whole address.  This is much of the reason that
     Intel chose this form of memory model for its earliest
     single-chip processors.

  -- There are segments for:
       
       code
       data
       stack
       other

  -- Which segment something is in can be implied by the memory
     access involved.  An instruction fetch will always be looking
     in the code segment. An instruction to push data onto the
     stack always accesses the stack segment.




 Addressing Modes
 ----------------

 Some would say that the Intel architectures only support 1 addressing
 mode.  It looks (something like) this:

  effective address = base reg + (index reg x scaling factor) + displacement

     where
       base reg is EAX, EBX, ECX, EDX or ESP or EBP
       index reg is EDI or ESI
       scaling factor is 1, 2, 4, or 8



  The syntax of using this (very general) addressing mode will
  vary from system to system.  It depends on the preprocessor
  and the syntax accepted by the assembler.

  For our implementation, an operand within an instruction that
  uses this addressing mode could look like
	  [EAX][EDI*2 + 80]

     The effective address calculated with be the contents of
     register EDI multiplied times 2 added to the constant 80,
     added to the contents of register EAX.
  
  There are extremely few times where a high-level language
  compiler can utilize such a complex addressing mode.  It is
  much more likely that simplified versions of this mode
  will be used.



  SOME ADDRESSING MODES

  --  register mode --
    The operand is in a register.  The effective address is the
    register (wierd).  

    Example instruction:

      mov  eax, ecx

      Both operands use register mode.  The contents of register ecx
      is copied to register eax.


  --  immediate mode --
    The operand is in the instruction.  The effective address is within
    the instruction.  

    Example instruction:

      mov  eax, 26

      The second operand uses immediate mode.  Within the instruction
      is the operand. It is copied to register eax.

  --  register direct mode --
    The effective address is in a register.

    Example instruction:

      mov  eax, [esp]

      The second operand uses register direct mode.  The contents of
      register esp is the effective address.  The contents of memory
      at the effective address are copied into register eax.


  --  direct mode --
    The effective address is in the instruction.

    Example instruction:

      mov  eax, var_name

      The second operand uses direct mode.  The instruction contains
      the effective address.  The contents of memory
      at the effective address are copied into register eax.



  --  base displacement mode --
    The effective address is the sum of a constant and the contents
    of a register.

    Example instruction:

      mov  eax, [esp + 4]

      The second operand uses base displacement mode.  The instruction
      contains a constant.  That constant is added to the contents
      of register esp to form an effective address.  The contents
      of memory at the effective address are copied into register eax.

  --  base-indexed mode --  (Intel's name)
    The effective address is the sum of the contents of two registers.

    Example instruction:

      mov  eax, [esp][esi]

      The contents of registers esp and esi are added to form an
      effective address.  The contents of memory at the effective
      address are copied into register eax.

      Note that there are restrictions on the combinations of registers
      that can be used in this addressing mode.

  --  PC relative mode --
    The effective address is the sum of the contents of the PC and
    a constant contained within the instruction.

    Example instruction:

      jmp  a_label

      The contents of the program counter is added to an offset that
      is within the machine code for the instruction.  The resulting
      sum is placed back into the program counter.  Note that from the
      assembly language it is not clear that a PC relative addressing
      mode is used.  It is the assembler that generates the offset
      to place in the instruction.




 Instruction Set
 ----------------

Generalities:
 -- Many (most?) of the instructions have exactly 2 operands.
    If there are 2 operands, then one of them will be required
    to use register mode, and the other will have no restrictions
    on its addressing mode.

 -- There are most often ways of specifying the same instruction
    for 8-, 16-, or 32-bit oeprands.  Note that
    on a 32-bit machine, with newly written code, the 16-bit form
    will never be used.


Meanings of the operand specifications:
   reg - register mode operand, 32-bit register
   reg8 - register mode operand, 8-bit register
   r/m - general addressing mode, 32-bit
   r/m8 - general addressing mode, 8-bit
   immed - 32-bit immediate is in the instruction
   immed8 - 8-bit immediate is in the instruction
   m - symbol (label) in the instruction is the effective address


   Data Movement
   -------------

      mov   reg, r/m                 ; copy data
	    r/m, reg
	    reg, immed
	    r/m, immed

      movsx reg, r/m8                ; sign extend and copy data

      movzx reg, r/m8                ; zero extend and copy data

      lea   reg, m                   ; get effective address
	 (A newer instruction, so its format is much restricted
	  over the other ones.)

	  EXAMPLES:

	  mov EAX, 23  ; places 32-bit 2's complement immediate 23
		       ; into register EAX
	  movsx ECX, AL  ; sign extends the 8-bit quantity in register
			 ; AL to 32 bits, and places it in ECX
	  mov [esp], -1  ; places value -1 into memory, address given
			 ; by contents of esp
	  lea EBX, loop_top ; put the address assigned (by the assembler)
			    ; to label loop_top into register EBX



   Integer Arithmetic
   ------------------

      add   reg, r/m                 ; two's complement addition
	    r/m, reg
	    reg, immed
	    r/m, immed

      inc   reg                      ; add 1 to operand
            r/m

      sub   reg, r/m                 ; two's complement subtraction
	    r/m, reg
	    reg, immed
	    r/m, immed

      dec   reg                      ; subtract 1 from operand
            r/m

      neg   r/m                      ; get additive inverse of operand

      mul   eax, r/m                 ; unsigned multiplication
                                     ; edx||eax <- eax * r/m

      imul   r/m                     ; 2's comp. multiplication
                                     ; edx||eax <- eax * r/m
             reg, r/m                ; reg <- reg * r/m
             reg, immed              ; reg <- reg * immed

      div   r/m                      ; unsigned division
				     ; does edx||eax / r/m
				     ; eax <- quotient
				     ; edx <- remainder

      idiv   r/m                     ; 2's complement division
				     ; does edx||eax / r/m
				     ; eax <- quotient
				     ; edx <- remainder

      cmp   reg, r/m                 ; sets EFLAGS based on 
            r/m, immed               ; second operand - first operand
            r/m8, immed8 
            r/m, immed8              ; sign extends immed8 before subtract 



	 EXAMPLES:

	 neg [eax + 4]    ; takes doubleword at address eax+4
			  ;   and finds its additive inverse, then places
			  ;   the additive inverse back at that address
			  ;   the instruction should probably be
			  ;      neg  dword ptr [eax + 4]

	 inc ecx          ; adds one to contents of register ecx, and
			  ;   result goes back to ecx



   Logical
   -------

      not   r/m                     ; logical not

      and   reg, r/m                ; logical and
            reg8, r/m8
	    r/m, reg
            r/m8, reg8
	    r/m, immed
	    r/m8, immed8

      or    reg, r/m                ; logical or
            reg8, r/m8
	    r/m, reg
            r/m8, reg8
	    r/m, immed
	    r/m8, immed8

      xor   reg, r/m                ; logical exclusive or
            reg8, r/m8
	    r/m, reg
            r/m8, reg8
	    r/m, immed
	    r/m8, immed8

      test  r/m, reg                ; logical and to set EFLAGS
            r/m8, reg8
	    r/m, immed
	    r/m8, immed8




         EXAMPLES:

	 and edx, 00330000h   ; logical and of contents of register
			      ;   edx (bitwise) with 0x00330000,
			      ;   result goes back to edx




   Floating Point Arithmetic
   -------------------------
   Since the newer architectures have room for floating point
   hardware on chip, Intel defined a simple-to-implement
   extension to the architecture to do floating point arithmetic.
   In their usual zeal, they have included MANY instructions to
   do floating point operations.

   The mechanism is simple.  A set of 8 registers are organized
   and maintained (by hardware) as a stack of floating point
   values.  ST refers to the stack top.  ST(1) refers to the 
   register within the stack that is next to ST.  ST and ST(0)
   are synonyms.

   There are separate instructions to test and compare the values
   of floating point variables.


      finit                         ; initialize the FPU

      fld   m32                     ; load floating point value
            m64 
            ST(i)

      fldz                          ; load floating point value 0.0

      fst   m32                     ; store floating point value
            m64 
            ST(i)

      fstp  m32                     ; store floating point value
            m64                     ;   and pop ST
            ST(i)

      fadd  m32                     ; floating point addition
            m64
            ST, ST(i)
            ST(i), ST

      faddp ST(i), ST               ; floating point addition
                                    ;   and pop ST





   Control Instructions
   --------------------
   All conditional control instructions in the Intel architectures
   are called jumps.  Their machine code is similar to the MIPS
   branch instructions.

   Just some of the many control instructions:
      jmp   m               ; unconditional jump
      jg    m               ; jump if greater than 0
      jge   m               ; jump if greater than or equal to 0
      jl    m               ; jump if less than 0
      jle   m               ; jump if less than or equal to 0


   Note that a control instruction takes a single operand, which
   specifies the jump target.  The conditional control instructions
   look at the condition code bits (in the EFLAGS register) to
   make a decision on whether to take the jump or not.

   The condition code bits are set by separate instructions.  Several
   arithmetic and logical instructions set some of the condition
   code bits.  There are also specific instructions to compare 
   operands and set the condition code bits based on the comparison
   (examples: cmp, test).




Some sample code, for fun:


Pentium code to add 1 to each element
of an array of integers.

Assume that there is an array of 100 integers
in memory.  The label associated with the first
element is int_array.

Comments are placed to the right, and preceded by
a semicolon (;).




      lea EAX, int_array      ; like la in MIPS, EAX is pointer
      mov ECX, 100            ; register ECX contains counter
loop_top:
      cmp ECX, 0              ; must set condition codes
      je  all_done            ; uses condition codes to branch
      inc [EAX]               ; a register direct addressing mode!
      add EAX, 4              ; updates pointer
      dec ECX                 ; update counter
      jmp loop_top            ; unconditional branch to loop_top

all_done:






Some things to notice about this code:
 -- You can figure it out, although you only know MIPS assembly
    language!  That is because most assembly languages look
    similar.
 -- The 2-address instruction set does not generate a larger number
    of instructions for this example (than a 3-address instruction
    set would, like MIPS).  It does do the same number of memory
    accesses.




Intel MMX (Optional)
---------

    MultiMedia eXtension to Intel Arch.
    [Peleg & Weiser, IEEE Micro, Aug. 96]

    Motivation
    ----------
    Q: Why might people want to buy newer, faster PCs?
    A: Processing audio and video
    
    Let's make audio and video perform better
    
        Method 1: add special-purpose card
        Method 2: make regular microprocessor perform better at audio/video
    
    Gist
    ----
    Intel's MMX follows Method 2
    The goal is 2x performance in audio, video, etc.

    Key observation: precision of data required << 32 bits

    For video,
    Red/Green/Blue might use 8 (16) bits each for 256 (64K) colors
    per pixel (picture element)

    Key technique:
	pack multiple low-precision items into a 64-bit floating-point register
	add instructions to manipulate them

    (This is an example of a general technique called
      "single instruction multiple data", or SIMD)

    MMX Datatypes
    -------------

    * 1 x 64 bit quad word
    * 2 x 32 bit double-word
    * 4 x 16 bit word
    * 8 x 8  bit byte
    
    MMX Instructions
    ----------------

    Example, ADDB (B stands for byte)

          17   87  100 ... 5 more
        + 17   13  200 ... 5 more
        ---- ---- ---- ...
          34  100   44 = 300 mod 256 ==> wraparound
                 255 = max value ==> saturating

	 This can be used to do arithmetic/logical operations on
	 more than 1 pixel's worth of data in 1 instruction.

   Also MOV's == load & stores


    Example
    -------
	16 element dot product (from matrix multiply)

        [a1 a2 ... a16]* [b1 b2 ... b16]^T = a1*b1 + b2*b2 + ... + a16*b16

	comparision with Intel IA-32 gives:
	
	->  32 loads
	->  16 *
	->  15 + 
	->  12 loop ctrl
  	   ---
   	    76 instructions
   	    int ==> 200 cycles
   	    fp  ==> 76 cycles

	Intel MMX assuming 16b values

	->  16 instructions
	->  12 cycles (6x better than fp)
	

    Other Instructions
    ------------------

	PACK/UNPACK -- putting multiple values in single register & back

	MASK

	   Example,  "make 0xff if equal"

                15   15 100  120  101   76   15   15
                15   15  15   15   15   15   15   15
               -------------------------------------
                FF   FF  00   00   00   00   FF   FF

	    Why? Mask for weatherman!

		* film weatherperson in front of blue background (0x15)
		* wthmsk = use above mask instruction
			wthmsk==FF -- no weatherperson
			wthmsk==00 -- weatherperson

		image = (~wthmsk & weatherperson ) | (wthmsk & weathermap)

             (What happens if weatherperson wears suit of color 15?)

    MMX Constraints
    ---------------

        * Instruction Set Architecture extensions, but perfect backward
	compatibility

        * 100% Operating System compatible (no new registers, flags,
	exceptions)

        * Independent Software Vendor (ISV) support (bit in CPUID instruction
	so applications can test for MMX and include code for both)




IA-64/Merced/Itanium (Optional)
------------

Motivation
   IA-32 has 32-bit addresses
   2^32 ==> 4G bytes of memory
   Current large servers want more!
   Near future medium servers will want more
   ...
   Someday desktops will want more?

   What to do?
       (1) Kludge IA-32 to support > 32-bit addresses
       (2) Do new instruction set with binary compatibility strategy
             (a) have new chips also support IA-32
             (b) use binary translation, etc.

   Intel claims to be doing 2a, but has only partially revealed plans.
   (as of Nov '98)

New instruction set architecture: IA-64
    64-bit addresses
    Mode for running old code
    First implementation is called "Merced"
    Uses "templates" and "predication" (defined below)

    Has extra large instructions so that 128b = 4 * 32b holds

        instrn0 instrn1 instrn2 template

        "template" gives "relationships" between instuctions
        example, whether instrn1 shares no registers or memory
	  locations w/ instrn0
        detail to be announced

    Each instruction is "predicated"
    Example,
        if $1 < $2
        then
            $3 = $4
        else
            $5 = $6
        endif

        Is normally:

              bge $1, $2, else
              mov $3, $4
              b endif
        else: mov $5, $6
        endif:

        With predication:

        setlt p0, $1, $2
        if (p0==TRUE) mov $3, $4
        if (p0==FALSE) mov $5, $6  /* three instructions & no branches */


Aren't you glad we did not teach 354 with IA-64/Merced?



all about the Cray 1
--------------------



  There has always been a drive to design the best, fastest computer in
  the world.  Whatever computer is the fastest has generally been called
  a supercomputer.

  The Cray 1 earned this honor, and was the fastest for a relatively long
  period of time.

  The man who designed the machine,  Semour Cray, is a bit of an eccentric,
  but he can get away with it because he's so good.  The Cray 1 has an
  exceptionally "clean" design, and that makes it fast.  (This is probably
  a bit exaggerated due to my bias -- the Cray 1 is probably my favorite
  computer.)

  Mostly my opinion:
  To make the circuitry as fast as possible, the Cray 1 took 2 paths
    1.  Physical -- a relatively "time-tested" technology was used, but
	much attention was paid to making circuits physically close
	(Semour was aware of the limits imposed by the speed of light.)
	and the technology was pushed to its limits.
    2.  Include only what was necessary, but on that, a "don't spare the
	horses" philosophy was used.
	This means that extra hardware was used (not paying attention to
	the cost) wherever it could to make the machine faster.  And, at
	the same time, any functionality that wasn't necessary (in Semour's
	opinion) was left out.  We'll see soon what that really means.
  Just remember:
    if something seems out of place to you, or some functionality of a
    computer that you think is essential and was not included in the Cray 1,
    it wasn't necessary!  And, leaving something out made the machine
    faster.

  What the Cray 1 is good for:
    it was designed to be used for scientific applications that required
    lots and lots of floating point manipulations.  It wouldn't make
    a good instructional machine (don't want to hook lotsa terminals up
    to it!), and it wouldn't be much fun to try to implement a modern
    operating system on.

  How it is used:
    most often, a separate (not as fast/powerful) computer was hooked up
    as what is commonly called a host computer.  The host is where you do
    all you editing and debugging of programs.  The host also maintains a
    queue of jobs to be run on the Cray.  One by one the jobs are run, so
    the only thing that the Cray is doing is running the final jobs -- often
    with LOTS of data.  Although its operating system would allow it,
    the "multi-tasking" (had more than 1 program running simultaneously)
    ability was not often used.




 instruction set
   fixed length instructions
     either 16 or 32 bit (no variablility that depends on
      the number of operands)
   number of operands possible for an instruction
     0-3
   number and kind of instructions
	     op codes are 7 bits long -- giving 128 instrucitons
	      This includes complete integer and floating point
	      instructions.

	      Notice that missing from the instruction set are:
		  character (byte) manipulation, duplicates
		  of anything (!), integer divide, etc.

   Data representation is simpified from what we've
      seen so far!  There are ONLY 2's complement integers,
      unsigned integers (for address manipulations),
      and floating point numbers!

      ALL accesses to memory are done in WORD chunks.  A word
      on the Cray 1 is 64 bits.  All instructions operate on
      a single size of data -- Either a 64 bit word, or on an
      address (24 bits).

   addressing modes (strikingly similar to MIPS)
     Register Mode.  An instruction (op code) specifies exactly where
           the data is.
     Base Displacement Mode.  Used only for load and store instructions.



   REGISTERS:
     There are an ENORMOUS number of registers.
     There are 5 types of registers.

	      S registers --  'S' stands for scalar.  These are 64-bit
	      registerss.  They are used for all sorts of data, but
	      not addresses.  There are 8.

	      T registers -- 
	      These are 64 64-bit backup registers for the S registers.
	      If you were to do some heavy programming on the Cray 1,
	      you'd find these registers very useful.  This is partially
	      because you run out of S registers quickly, so you
	      need temporary storage, but don't want your program
	      to store to main memory (slow!).  There's also an
	      instruction that allows you to load a block of memory
	      to the T registers.  That's 1 instruction to do up to 64
	      loads.

	      A registers --  'A' stands for address.  These are
	      24-bit registers.  They are used for addresses, and to a
	      rather limited extent, integer counters.

	      B registers --
	      These are backups to the A registers and are used in the
	      same manner as the T registers.

	      V registers -- 'V' stands for vector. 
	      There are 8 sets of V registers.  Each set has 64 64-bit
	      registers!  That is a lot!  They are used mainly for
	      processing large quantities of "array" data.  Their use
	      makes the Cray 1 very fast.  A single instruction that uses
	      a vector register (1 set) will cause something to happen
	      to each of the 64 registers within that set.
	      (SIMD)



    So, if we had parallel arrays of data, and wanted to add
    corresponding elements of the arrays, storing the sum in
    the corresponding element of a third array, this would be
    essentially 4 instructions on the Cray-1.

    1. block load (of part or all of first array) to V0
    2. block load (of part or all of second array) to V1
    3. vector add,   V0 + V1 --> V2
       Note that the vector add can do the add (using lots of pipelining)
       to all of a vector register (64 adds), or to just a subset of
       the vector (starting with element 0).
    4. block store (of part or all of first array) of V2

	      V0                     V1                V2
         --------------         --------------      --------------
       0 |            |    +    |            |  =   |            |
         --------------         --------------      --------------
       1 |            |    +    |            |  =   |            |
         --------------         --------------      --------------
         |            |         |            |      |            |
	       .                       .                  .
	       .                       .                  .
	       .                       .                  .
         --------------         --------------      --------------
         |            |    +    |            |  =   |            |
         --------------         --------------      --------------
     63  |            |    +    |            |  =   |            |
         --------------         --------------      --------------


    For accomplishing this same operation where the arrays contain more
    than 64 elements, put these 4 instructions into a loop, where each
    iteration of the loop works on 64 of the elements.




   hardware stack
	      no support for stack accesses at all!  There is no
	      special stack pointer register.
   cache
	      none.  There are so many registers that there isn't
	      really a need for one.

   size of machine
	     A bit bigger than 2 refridgerators.
   speed of machine
	     Significantly faster than the VAX and 68000.
	      For a while, it was the fastest machine around.

   price of machine
	     As an analogy to some very pricey restaurants:
	      If you need to see the prices on the menu, you can't
	      afford to eat there.

	      Probably about $3 million for the basic machine when
	      they first came out.

	      A Cray 1 came with a full time hardware engineer,
	      (a field service person).  Why?  Down time on a Cray
	      is very expensive due to the way they are expected to
	      be used.  Waiting for field service to come was
	      considered too expensive.
   how many instructions get executed at one time
	 its debatable.  There can be more than 1 instruction
	  at some point in its execution at 1 time.  It is a
	  pipelined machine. This can only go so far (only
	  1 new instruction can be started each clock cycle).
  complexity of ALU
	  There are actually quite a few ALU's in the machine.
	  Cray calls them functional units.  Each one is a specialized
	  piece of hardware that does its own job as fast as can
	  be done.  Each of them could conceivably be working at
	  the same time.




on the VAX
----------

The VAX was a popular and commercially successful computer
put out in the early 1970's by DEC (Digital Equipment Corp).

It might be characterized by the term CISC.
    RISC (Reduced Instruction Set Computer)
    CISC (Complex Instruction Set Computer)

A CISC computer is often characterized by
  1.  many instructions
  2.  lots of addressing modes
  3.  (this one is debatable) variable length instructions
  4.  memory-to-memory architecture

Some details of the VAX:

  It used microcode to control its operation.  Microcode is a hardware
  implementation of a program.  For each clock cycle, something happens.
  That something is that bits that control ALL the different aspects
  of a processor's operation need to be set.

there were LOTS OF INSTRUCTIONS
 integer arithmetic
   different opcodes for varying size data
 logical
   different opcodes for varying size data
 address manipulations
 bit manipulations
 control instructions
   conditional branches, jumps, looping instructions
 procedure mechanisms
   call and return instructions (there were more than 1!)
   (they do it all in a single instruction, like saving registers,
   saving the return address, and jumping to the first instruction
   within the procedure)
 floating point
   Operations on 4 different representations of floating point numbers.
   Remember that the VAX came out long before the IEEE standard on 
   floating point arithmetic.
 character string manipulations
 crc (Cyclic Redundancy Check)
 decimal string
   arithmetic presuming representation of binary coded decimal
 string edit

 overall:  more than 200 instructions

 opcodes were of variable length, but always a multiple
 of 8 -- most opcodes were specified in the first 8 bits
 of an instruction.




REGISTERS
  16 32-bit general purpose registers,
  except that they really weren't all general purpose
    R15 is the PC -- note that the user can change the
		     PC at will!
    R14 is a stack pointer
    R13 is a frame pointer
    R12 is an argument pointer (address of where a procedure's
	  parameters are stored -- sometimes on the stack,
	  and sometimes in main memory)

DATA TYPES
 byte
 word (16 bits)
 longword (32 bits)
 quadword (64 bits)
 octaword (128 bits)

 F floating point (32 bits -- 7 bits of exponent)
 D floating point (64 bits -- 7 bits of exponent)
 G floating point (64 bits -- 10 bits of exponent)
 H floating point (128 bits -- 15 bits of exponent)

 character string (consecutive bytes in memory, specified always
		   by a starting address and the length in bytes)
 numeric string  (the ASCII codes that represent an integer)
 packed decimal string (consecutive sequence of bytes in memory
     that represent a BCD integer.  BCD digits are each in
     4-bit quantities (a "nibble")

       example:  the integer +123 is represented by
	       0001     0010   0011       1100
	       (1)      (2)    (3)        (+)
   numbering   a<7-4> a<3-0>  a+1<7-4>  a+1<3-0>


each instruction operates on a fixed data type



OPERAND ACCESS

 the number of operands for each individual instructions
 is fixed

 the location of operands is definitely not fixed,
   they can be in memory, or registers, and the variety
   of addressing modes that specify the location of an
   operand is large!

 equivalent of  MIPS     add $2, $3, $4

    addl3  R3, R4, R2
       ^^
       ||-- 3 operands
       |
       |--- operate on a 32 bit quantity

 There is also  addb3, addw3,  addb2, addw2, addl2 for 2's complement
   addition.
 There is also  addp4, addp6  for bcd addition.
 There is also  addd3, addd2, addf3, addf2, addg3, addg2, addh3, addh2,
   for floating point addition.



 This is a VERY simple use of addressing modes.
 The syntax of operand specification allows MANY possible
   addressing modes -- every one discussed in chapter 8,
   plus more!

   for example
       addl3 (R3), R4, R2
	 uses Register Direct addressing mode for the first
	 operand --
	 operation
	   the address of the first operand is in R3,
	   load the operand at the address, add to the
	   contents of R4, and place the result into R2

  The addressing mode for each operand can (an often is)
  be different!



One type addressing mode (not discussed in the text) sticks out --
auto-increment and auto-decrement
  They have the side effect of changing the address used to get
  an operand, as well as specifying an address.

    addl3 (R3)+, R4, R2
    operation
      the address of the first operand is in R3,  load
      the operand at the address, then increment the contents
      of R3 (the address), then add data loaded from memory
      to the contents of R4 and place the result into R2

      the amount added to the contents of R3 depends on the
      size of the data being operated on.  In this case, it
      will be 4 (longwords are 4 bytes)



MACHINE CODE

Together with each operand is an addressing mode specification.
Each operand specification requires (at least) 1 byte.

Format for the simple  addl3 R3, R4, R2

   8-bit opcode   0101 0011    0101 0100   0101 0010
		   ^    ^       ^    ^      ^    ^
		   |    |       |    |      |    |
		   ---- | ---------- | --------- | -- mode (register = 5)
		        |            |           |
		        |------------|-----------|--- which register


Format for the     addl3 (R3), R4, R2

      same
   8-bit opcode   0110 0011    0101 0100   0101 0010
		   ^    ^       ^    ^      ^    ^
		   |    |       |    |      |    |
		   ---- | ---------- | --------- | -- mode
		        |            |           |
		        |------------|-----------|--- which register


Each instruction has an 8-bit opcode.
There will be 1 8-bit operand specifier for each operand that
  the instruction specifies.

Because of the large number and variety of addressing modes,
an operand specification can be much more than 1 byte.
Example:  Immediates are placed directly after their specification
within the code.



Here's an example that will help to show the powerful way that these
addressing modes can reduce the size of the code (fewer instructions
when compared to a RISC architecture).


Suppose we had the following problem.
  We want to add the constant 220 to each element of an array.

  On the MIPS, we would place into a loop the following instructions:

	 # assumes that $s0 initially contains the address of the
	 # first element of the array.  The initialization is
	 # outside the loop.
         lw   $t0, ($s0)
	 addi $t0, $t0, 220
	 sw   $t0, ($s0)
	 addi $s0, $s0, 4

  On the VAX, the contents of this loop can be a single instruction!
	 # assumes that R3 initially contains the address of the
	 # first element of the array.  The initialization is
	 # outside the loop.
	 addl3  (R3), #220, (R3)+

	 The constant to be added can be placed directly into the code.
	 The autoincrement mode updates the address of the array element
	 after the current address is used.  And the memory location
	 for the result is also given.


The machine code for this VAX instruction:

   addl3        (R3)       #220                           (R3)+
8-bit opcode   
1100 0011      0110 0011   1000 1111  00. . .010110100   1000 0011
               mode reg    mode reg   ^^32-bit immed^^   mode reg

A comparison of VAX to MIPS reveals,
   8 bytes total for encoding on the VAX
   4 instructions * 4 bytes per instruction = 16 bytes on the MIPS



PERFORMANCE

  the term MIPS (millions of instructions per second) really came
  from the VAX -- 
    the VAX 11 780 ran at just about 1 MIPS
  note that this term is misleading --
    Instructions take variable times to fetch and execute,
    so the performance depends on the program



SIZE
  one version:  the VAX11 730 was about the size of a bread box, and
                it was really slow!
  another version:  the VAX11 750 was about the size of a large-capacity
		washing machine, and 1 person could keep it busy easily.
  yet another version:  the VAX11 780 was about the size of 2 refridgerators,
		standing side by side.  This one was the "work horse" of
		the 1980s.


the SPARC architecture
----------------------


SPARC, an acronym from Scalable Processor ARChitecture

introduced by Sun Microsystems in 1985
  goal: to be easy to use for an optimizing compiler, and to allow
  for easily pipelined implementations (this is from the SPARC-V8
  Architecture Manual, copyright 1991)

  now called SPARC-V8 (32-bit version)
             SPARC-V9 (64-bit version)
             
             

the SPARC-V8 architecture
--------------------------

info on web at http://www.sparc.com/standards/V8.pdf

an architecture similar to the MIPS RISC architecture.

  -- load/store architecture
  -- all machine code instructions (like the MIPS) are exactly 32 bits long
  -- condition codes used with conditional control instructions
  -- 3-address instruction set
  -- an unusual (compared to MIPS) 32 register file (for non-floating point)
  -- delayed branch technique (similar to MIPS)
  -- follows IEEE 754 standard on floating point arithmetic
  -- memory is byte-addressable



DATA TYPES

integers are two's complement, and they come in various sizes
  (1, 2, 4, and 8 -byte sizes)
floating point values follow the IEEE 754 standard
characters are Unicode values

ADDRESSING MODES
  for a load/store instruction, there are 2 addressing modes use to
  produce an effective address.
  1.  base displacement (much like the MIPS)
      A small immediate value (the displacement) is in the instruction.
      It is added to the contents of a register to form the effective
      address.
  2.  Two registers are specified.  The effective address is the sum
      of the values from the registers.  One source calls this
      addressing mode Register-indirect with index.

REGISTERS
  the "unusual" and inovative aspect of the architecture.

  At any one time, a set of 32 (32-bit) registers is available for
  use within instructions.  Yet, there may be many more registers
  implemented (broken into 16-register sets). There will be 2-32 sets
  in the actual HW implementation.

  Of the 32 registers,
    8 are global
    8 are input arguments
    8 are for local variables
    8 are for output parameters
  
  The set of registers, other than the 8 global registers,
  forms a stack.  As a procedure is
  called, the REGISTER WINDOW, changes.  It works like a push
  of a new activation record.  At the return from a procedure,
  the register window changes, like a pop of an activation record.

  Which register window is currently being used is given by
  bits 4..0 of the PSR.



  A picture is worth much more than a thousand words in this case.
     Assume that A calls B, and B calls C.  Assume (for simplicity)
     that each passes 8 or fewer parameters.

     A diagram of the register file:


                      | R0 - R7 (global)    |
                      | (R0 is 0, like MIPS)|
                      |---------------------|
                   ---| 8 Parameter         | A: R8-R15, input parameters
                   |  |   registers         | 
                   |  |---------------------|
             A's   |  | 8 Locals            | A: R16-R24, local variables
           register|  |                     |
           window  |  |---------------------|
                 --|  | 8 Parameter         | A: R24-R31, outgoing params
                 | |--|   registers         | B: R8-R15, input parameters
                 |    |---------------------|
          B's    |    | 8 Locals            | B: R16-R24, local variables
      register   |    |                     |
      window     |    |---------------------|
               --|    | 8 Parameter         | B: R24-R31, outgoing params
               | |--- |   registers         | C: R8-R15, input parameters
               |      |---------------------|
       C's     |      | 8 Locals            | C: R16-R24, local variables
     register  |      |                     |
     window    |      |---------------------|
               |      | 8 Parameter         | C: R24-R31, outgoing params
               |------|   registers         |   (unused if C is a leaf)
                      |---------------------|
		             |
			    \ /  stack grows in this direction


So, what really happens is that at a procedure call, the set of
registers accessed as R8-R31 changes.  In comparison to the MIPS
processor, this may eliminate memory accesses for load and store
instructions in the case where input parameters are live across
a call.  It also eliminates memory accesses for those cases where
there are 5-8 parameters being passed.  MIPS requires these to
be in the activation record (on the stack, in memory).

The SPARC will introduce extra memory accesses in the case where
scoping rules nest "local" variables.  If a variable is local
to 2 procedures, a SPARC compiler would need to allocate memory
space for temporarily holding the local variable.  There will be
memory accesses (loads/stores) for both procedures to access the
variable.

There can also be a fair number of memory accesses generated if the
number of implemented (in HW, on the chip) register windows is
fewer than the number needed (due to the level nested calls).



INSTRUCTION SET

Conditional control instructions are based upon condition codes.
The condition codes are kept in a control register called the PSR
(Processor State Register).
  bits 23..20 of this register are used as
              23    22    21   20
	      n     z     v    c
	      |     |     |    |---  Carry
	      |     |     |--------  overflow
	      |     |-------------  zero (1 = zero)
	      |------------------  negative (1 = negative)

  The mnemonic of the assembly language instructions identifies
  which instructions set the condition codes.  The string "cc"
  appended to the mnemonic indicates that the instruction sets
  condition codes.

EXCEPTION HANDLING

A trap causes the register window to change.  A copy of the
PC (before the trap) is saved in the new window.

A control register (called TBR, the Trap Base Register) forms
an address that is the first 4 instructions within a handler.
Part of the TBR is set as the machine is started up (booted).

          TBR

    bits   31                     12  11      4  3 2 1 0
	  ------------------------------------------------
	  |base address               trap type  0 0 0 0 |
	  ------------------------------------------------

    The 2 least significant bits are 0s, since addresses are
    byte addressable, and instructions are 4 bytes long and
    (like the MIPS) they are word-aligned.  There are 4 instructions
    at each of these addresses (formed by the TBR), so 2 more
    bits of this address are 0s.


Bits 11..8 of the PSR identify a priority level for interrupts
above which interrupts will be handled.

Bit 7 of PSR is whether the processor is currently in 
  supervisor mode = 1
  user mode = 0
  (this is the equivalent of the K/U bit in the MIPS Status register)
</pre>

<html>
<head>
<title> Lecture notes - about Virtual Memory</title>
</head>

<BODY>
<h1> Virtual Memory</h1>

<pre>


Much of this subject straddles the areas of architecture and operating
  systems.  Must understand both to get it right.



Problems:

  -- Physical memory is too small.
     (Smaller than the address space of the machine,
      for example, 32-bit address = 4K Mbytes, or 4 Gbytes,
      but main memory is only 16 Mbytes.)

      We want to have just parts of a program in memory, not the
      entire (potentially very large) program

  -- Want ability to have multiple processes somewhere in their
     execution.  Want to increase throughput of computer by allowing
     multiprogramming, multitasking.

     The programs (processes) need to SHARE main memory.
        need RELOCATION, OS-controlled SWAPPING

  -- Large, inexpensive memory (disk) is slow.


Solution:

  Make main memory a cache for the larger disk.

  Give OS some "hooks" to ease its job.

  Introduce notion of an ADDRESS SPACE.




Address Space
-------------
Associated with every program (process) is a set of addresses
 that it may reference.

  PROCESS -- a program, together with some processor state.


 For a 32-bit address machine, want 32 bits of address space available
 to the program.  And, every process wants access to the full
 address space.

 To do this, introduce the notion of a VIRTUAL ADDRESS SPACE.

     virtual address            easily generated by SW

          |
          |
         \ /

       translation

          |
          |
         \ /

   physical address            used by HW to access memory
   (also called a real address)


  TO REMEMBER:  need the translation to be fast, since it must
                be done for every memory access.
		That means that it must be done by HW.




Base and Bounds
---------------
 Give 2 HW registers, can implement virtual memory.
  
 base --  base address for a process -- a physical (real) address
 bounds -- last valid virtual address process may access
 virtual addresses generated by process are offsets from the base








 
  -- for each reference, must check if the address is within bounds.
  -- each process has its own space
  -- each process must be allocated contiguously in memory
  -- cheap to implement in HW.  Addition and comparison can be
     done in parallel.

 Problems:
  -- impossible to share code between 2 programs (while keeping
     other code/data private to a program). This is because there
     is only 1 segment for each process. 



Segmentation
------------

  Permit portions of process to be split into more than 1 area of
  memory (SEGMENTS)
     one for code
     another for heap
     another for stack

  Use separate base and bounds for each segment.
  Could add some sort of protection bit for each segment, to allow
    sharing.














  Problems:

  -- Need table for segments/base/bounds info.  Could get big.
  -- External fragmentation of memory.



Paging
------
  break up main memory into evenly sized PAGES.

  PAGE TABLE give address of either
     1) base of physical page in main memory
  or 2) address of page on disk

    each entry also has PRESENT bit (called VALID bit in book,
    to draw an analogy to cache's valid bit).  Present bit
    identifies whether physical page is resident in main memory
    or not.

  Have one page table for each process.  Its base address is kept in
    a register in the CPU.

  Placement of pages in memory is easy.  OS keeps a free list, and
    just take one from list.  
















  Problems:

  -- It takes 2 memory accesses to get one piece of data.
         One to access the page table entry.
         One to get the data.
     Solution:
         TLB (Translation Lookaside Buffer) as a cache for page table.
  -- For reasonable size memory, page table is huge.
     Solutions:
       Keep base/bounds for page table, so only have pages needed
       in table
  -- Internal fragmentation. (Page size is aways wrong for some
       processes.



PAGING AND SEGMENTATION
-----------------------

  To reduce table sizes, use 2 levels of mapping.

  Each segment contains an integral number of pages.  The number of
    pages can vary for each segment.

  Keep a page table for each segment.

  Both external and internal fragmentation are kept at bay.


























  Problems:

  -- If tables are in memory, can take more than one memory access
     to get at a piece of data.
     Solution:   TLB



TLB (Translation Lookaside Buffer)
-----

  A process typically accesses only a few of its pages at time, and
  accesses them repetitively.  (Showing both spacial and temporal
  locality.)


  TLB conatins a mapping of virtual page number (the TAG) to a
    physical page number.

  Also included,
     Present bit
     Referenced bit(s) - To help know chose victim if no free pages.
     Protection - to facilitate sharing
     Dirty bit - done at page level, not cache level.
     Process ID - sometimes added so that the TLB does not have
        to be flushed at each context switch.






















  TLB typically contains 98% or more of the pages accessed.

  Typical size is 64-128 entries.  Small TLB can be made
    fully associative.

  There is a difference between miss in the TLB and a page fault.




PAGE FAULTS
-----------
  What happens if the page is not resident in main memory.

 - In translation, present bit is off.

   - Many machines trap (take an exception).

     - OS invoked to allocate free physical page from free list,
      or choose a "victim,"  the physical page to be thrown out
      of main memory to make room for faulted page.  Have to
      write current victim page to disk if dirty.

       - OS initiates disk access (really slow, 1msec or more),
         brings page into memory, updates page table and TLB,
         sets present bit

         - Instruction that cause page fault is restarted.


 Note that restarting instructions can be a tricky business.
    IBM 370 ran "long" instructions twice,
         First time just to access each memory location (read),
         to generate any potential page faults.
         Second time to do the actual instruction, guaranteed not
         to page fault.
    Z8000 solution, have 2 processors, one just for handling page
         faults.
</pre>
